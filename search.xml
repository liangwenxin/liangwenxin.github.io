<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>VIM入门操作、</title>
    <url>/2020/03/28/VIM%E5%85%A5%E9%97%A8%E6%93%8D%E4%BD%9C%E3%80%81/</url>
    <content><![CDATA[<h4 id="1、Vim编辑器的模式"><a href="#1、Vim编辑器的模式" class="headerlink" title="1、Vim编辑器的模式"></a>1、Vim编辑器的模式</h4><ul>
<li>正常模式 (Normal-mode)</li>
<li>插入模式 (Insert-mode)</li>
<li>命令模式 (Command-mode)</li>
<li>可视模式 (Visual-mode)</li>
</ul>
<h5 id="2、-vimrc-配置vim编辑器的配置"><a href="#2、-vimrc-配置vim编辑器的配置" class="headerlink" title="2、.vimrc 配置vim编辑器的配置"></a>2、.vimrc 配置vim编辑器的配置</h5><p>syntax on //语法高亮<br>set number //显示行号</p>
<h5 id="3、移动光标"><a href="#3、移动光标" class="headerlink" title="3、移动光标"></a>3、移动光标</h5><p>在命令模式下：可以使用h、j、k、l键分别代表方向键←↓↑→</p>
<p><img src="/2020/03/28/VIM入门操作、/C:/Users\xin\AppData\Roaming\Typora\typora-user-images\image-20200328232945105.png" alt="image-20200328232945105"></p>
<p>w（word）：键盘可以以单词为单位跳<br>b（back）：键可以往回以单词为单位跳</p>
<p>ctrl+f（forward）：可以往下翻页 等于Pg up<br>ctrl+b（backward）：可以往上翻页 等于Pg down</p>
<p>数字+gg：可以以数字为行数跳到第数字行，10gg跳到第10行<br>数字+j、k：可以以数字为行数跳转，10j往下跳10行，10k网上跳10行</p>
<p><strong>/查找的内容</strong><br>n（next）：可以查找下一个<br>shitf+n（next）：查找上一个</p>
<p>cc：剪贴删除会自动跳入编辑模式<br>p：粘贴插入复制的行<br>yy（yank）：复制当前行，2yy复制两行<br>c数字c：删除数字的行数，c2c删除两行<br>dd：删除当前行，2dd删除两行</p>
<p>u（undo）：撤回操作</p>
<p>shift+g：跳到最后一行</p>
<h4 id="3、视图模式"><a href="#3、视图模式" class="headerlink" title="3、视图模式"></a>3、视图模式</h4><p>c：剪切<br>p：粘贴</p>
<p>ctrl+n：自动补全</p>
<p>vim plug自动补全插件</p>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>C++容器的使用-vector</title>
    <url>/2020/03/27/C-%E5%AE%B9%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h2><p>Vectors 包含着一系列连续存储的元素,其行为和数组类似。访问Vector中的任意元素或从末尾添加元素都可以在常量级的时间内完成，而查找特定值的元素所处的位置或是在Vector中插入元素则是[线性时间复杂度。</p>
<table>
<thead>
<tr>
<th><a href="cppvector_details.html#Constructors">Constructors</a></th>
<th>构造函数</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="cppvector_details.html#Operators">Operators</a></td>
<td>对vector进行赋值或比较</td>
</tr>
<tr>
<td><a href="cppvector_details.html#assign">assign()</a></td>
<td>对Vector中的元素赋值</td>
</tr>
<tr>
<td><a href="cppvector_details.html#at">at()</a></td>
<td>返回指定位置的元素</td>
</tr>
<tr>
<td><a href="cppvector_details.html#back">back()</a></td>
<td>返回最末一个元素</td>
</tr>
<tr>
<td><a href="cppvector_details.html#begin">begin()</a></td>
<td>返回第一个元素的迭代器</td>
</tr>
<tr>
<td><a href="cppvector_details.html#capacity">capacity()</a></td>
<td>返回vector所能容纳的元素数量(在不重新分配内存的情况下）</td>
</tr>
<tr>
<td><a href="cppvector_details.html#clear">clear()</a></td>
<td>清空所有元素</td>
</tr>
<tr>
<td><a href="cppvector_details.html#empty">empty()</a></td>
<td>判断Vector是否为空（返回true时为空）</td>
</tr>
<tr>
<td><a href="cppvector_details.html#end">end()</a></td>
<td>返回最末元素的迭代器(译注:实指向最末元素的下一个位置)</td>
</tr>
<tr>
<td><a href="cppvector_details.html#erase">erase()</a></td>
<td>删除指定元素</td>
</tr>
<tr>
<td><a href="cppvector_details.html#front">front()</a></td>
<td>返回第一个元素</td>
</tr>
<tr>
<td><a href="cppvector_details.html#get_allocator">get_allocator()</a></td>
<td>返回vector的内存分配器</td>
</tr>
<tr>
<td><a href="cppvector_details.html#insert">insert()</a></td>
<td>插入元素到Vector中</td>
</tr>
<tr>
<td><a href="cppvector_details.html#max_size">max_size()</a></td>
<td>返回Vector所能容纳元素的最大数量（上限）</td>
</tr>
<tr>
<td><a href="cppvector_details.html#pop_back">pop_back()</a></td>
<td>移除最后一个元素</td>
</tr>
<tr>
<td><a href="cppvector_details.html#push_back">push_back()</a></td>
<td>在Vector最后添加一个元素</td>
</tr>
<tr>
<td><a href="cppvector_details.html#rbegin">rbegin()</a></td>
<td>返回Vector尾部的逆迭代器</td>
</tr>
<tr>
<td><a href="cppvector_details.html#rend">rend()</a></td>
<td>返回Vector起始的逆迭代器</td>
</tr>
<tr>
<td><a href="cppvector_details.html#reserve">reserve()</a></td>
<td>设置Vector最小的元素容纳数量</td>
</tr>
<tr>
<td><a href="cppvector_details.html#resize">resize()</a></td>
<td>改变Vector元素数量的大小</td>
</tr>
<tr>
<td><a href="cppvector_details.html#size">size()</a></td>
<td>返回Vector元素数量的大小</td>
</tr>
<tr>
<td><a href="cppvector_details.html#swap">swap()</a></td>
<td>交换两个Vector</td>
</tr>
</tbody>
</table>
<p>vector可以⼀一开始不不定义⼤大⼩小，之后⽤用resize分配⼤大⼩小，也可以⼀一开始就定义⼤大⼩小，之后还可以对它 插⼊入删除动态改变它的⼤大⼩小～⽽而且不不管在main函数⾥里里还是在全局中定义，它都能够直接将所有的值初 始化为0（不不⽤用显式地写出来，默认就是所有的元素为0），</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2(<span class="number">10</span>,<span class="number">1</span>); <span class="comment">//将v2设置为长度为10内容为1</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">10</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">       <span class="comment">// v1.push_back(i); //在v1的末尾添加元素i</span></span><br><span class="line">		v1.push_back(arr[i]); <span class="comment">//在v1的末尾添加元素arr[i]</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> it = v1.begin();it != v1.end();it++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; *it &lt;&lt;<span class="string">" "</span>; <span class="comment">//使用迭代器的方式访问v1</span></span><br><span class="line">	&#125;	<span class="comment">//v1.begin()是一个指针指向容器的第一个元素</span></span><br><span class="line">    	<span class="comment">//v1.end()指向容器的最后一个元素</span></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; v1.size() &lt;&lt; <span class="built_in">endl</span>;; </span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> it = v2.begin();it != v2.end();it++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; *it &lt;&lt;<span class="string">" "</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>容器器vector、set、map这些遍历的时候都是使⽤用迭代器器访问的，v1.begin()是⼀个指针，指向容器器的第⼀个元素，v1.end()指向容器器的后⼀个元素的后⼀个位置，所以迭代器器指针it的for循环判断条件是it != v1.end().访问元素的值要对it指针取值，要在前⾯面加星号～所以是cout &lt;&lt; *it; </p>
<p><strong>vector初始化的方式</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a(<span class="number">10</span>);<span class="comment">//定义10个整形元素</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a(<span class="number">10</span>,<span class="number">1</span>);<span class="comment">//定义10个整形元素，初始值为1</span></span><br><span class="line"><span class="keyword">int</span> b[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a(b);<span class="comment">//向量a的值等于向量b的值</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a(b.begin(),b.end())<span class="comment">//把b的值给a</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a(b,b+<span class="number">5</span>)<span class="comment">//从数组b中获取值</span></span><br></pre></td></tr></table></figure>
<p><strong>vector读取元素的方式</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; b(a,a+<span class="number">5</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; b.size()<span class="number">-1</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; b[i] &lt;&lt;<span class="built_in">endl</span>;<span class="comment">//利用下标读取数据</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = b.begin();it != b.end();it++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *it &lt;&lt;<span class="built_in">endl</span>; <span class="comment">//使用迭代器读取数据  </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> it = b.begin();it != b.end();i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *it &lt;&lt;<span class="built_in">endl</span>;<span class="comment">//使用迭代器auto方式读取数据</span></span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> s = &#123;<span class="string">"hello,world"</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">char</span> c:s) <span class="comment">//以字符的方式读取数据</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; c &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">string</span> str[]=&#123;<span class="string">"hello"</span>,<span class="string">"world"</span>,<span class="string">"this"</span>,<span class="string">"find"</span>,<span class="string">"gank"</span>,<span class="string">"pink"</span>,<span class="string">"that"</span>,<span class="string">"when"</span>,<span class="string">"how"</span>,<span class="string">"cpp"</span>&#125;;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; str1(str,str+<span class="number">10</span>);<span class="comment">//从数组str中获取</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; str1;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">10</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		str1.push_back(str[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> it = str1.begin();it != str1.end();it++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; *it &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; str[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>hello,world</title>
    <url>/2020/03/02/hello-world/</url>
    <content><![CDATA[<h2 id="hello-world"><a href="#hello-world" class="headerlink" title="hello,world"></a>hello,world</h2><p>today is 2020,3.2,13:14</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2019/11/12/linux-http-apache/</url>
    <content><![CDATA[<h6 id="以下是关于apache配置的帮助网站"><a href="#以下是关于apache配置的帮助网站" class="headerlink" title="以下是关于apache配置的帮助网站"></a>以下是关于apache配置的帮助网站</h6><p><a href="http://www.apache.org/" target="_blank" rel="noopener">http://www.apache.org/</a><br><a href="https://www.cnblogs.com/sxchengchen/p/7856810.html" target="_blank" rel="noopener">https://www.cnblogs.com/sxchengchen/p/7856810.html</a><br><a href="https://blog.csdn.net/weixin_43466473/article/details/88862062" target="_blank" rel="noopener">https://blog.csdn.net/weixin_43466473/article/details/88862062</a></p>
<h4 id="1、安装http服务"><a href="#1、安装http服务" class="headerlink" title="1、安装http服务"></a>1、安装http服务</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum -y intsll http*</span><br></pre></td></tr></table></figure>
<h4 id="2、创建一个或多个网站"><a href="#2、创建一个或多个网站" class="headerlink" title="2、创建一个或多个网站"></a>2、创建一个或多个网站</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi /etc/httpd/conf/httpd.conf //在文档的末尾添加如下代码</span><br><span class="line">&lt;VirtualHost 1.1.1.110：80&gt;</span><br><span class="line">	ServerAdmin admin@www1.lwx.com //管理邮箱</span><br><span class="line">	DocumentRoot /var/www/html/www1 //目录</span><br><span class="line">	ServerName www1.lwx.com //域名</span><br><span class="line">	ErrorLog logs/www1_error_log //错误日志</span><br><span class="line">	Customlog logs/www1_access_log common //错误日志</span><br><span class="line">&lt;/VirtualHost&gt;</span><br><span class="line"></span><br><span class="line">&lt;VirtualHost 1.1.1.110：80&gt;</span><br><span class="line">	ServerAdmin admin@www2.lwx.com</span><br><span class="line">	DocumentRoot /var/www/html/www2</span><br><span class="line">	ServerName www2.lwx.com</span><br><span class="line">	ErrorLog logs/www2_error_log</span><br><span class="line">	Customlog logs/www2_access_log common</span><br><span class="line">&lt;/VirtualHost&gt;</span><br></pre></td></tr></table></figure>
<h4 id="3、创建目录以及主页文档"><a href="#3、创建目录以及主页文档" class="headerlink" title="3、创建目录以及主页文档"></a>3、创建目录以及主页文档</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd /var/www/html/www1 </span><br><span class="line">echo &quot;this is my www1.lwx.com&quot; &gt;&gt; index.html</span><br></pre></td></tr></table></figure>
<h4 id="4、配置dns解析文件"><a href="#4、配置dns解析文件" class="headerlink" title="4、配置dns解析文件"></a>4、配置dns解析文件</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">正向文件</span><br><span class="line">www1 IN A 1.1.1.110 //www1.lwx.com对应的地址</span><br><span class="line">www2 IN A 1.1.1.110 //www2.lwx.com对应的地址</span><br><span class="line">反向文件</span><br><span class="line">110 IN PTR www1.lwx.com.</span><br><span class="line">110 IN PTR www1.lwx.com.</span><br><span class="line"></span><br><span class="line">systemctl restart named //重启dns服务</span><br><span class="line"></span><br><span class="line">vi /etc/reslov.conf //设置主机或客户端dns服务器地址</span><br></pre></td></tr></table></figure>
<h4 id="5、重启http服务器以及测试"><a href="#5、重启http服务器以及测试" class="headerlink" title="5、重启http服务器以及测试"></a>5、重启http服务器以及测试</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl restart httpd //重启</span><br><span class="line">curl www1.lwx.com</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>linux--samba</title>
    <url>/2019/11/06/linux-samba/</url>
    <content><![CDATA[<h4 id="1、安装samba服务"><a href="#1、安装samba服务" class="headerlink" title="1、安装samba服务"></a>1、安装samba服务</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install samba*</span><br></pre></td></tr></table></figure>
<h4 id="2、添加用户"><a href="#2、添加用户" class="headerlink" title="2、添加用户"></a>2、添加用户</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">useradd jsjuser #添加用户</span><br><span class="line">smbpasswd -a jsjuser #设置密码</span><br><span class="line">groupadd jsjusers #添加用户组</span><br><span class="line">usermod -G jsjusers jsjuser #将用户添加到组中</span><br></pre></td></tr></table></figure>
<h4 id="3、创建目录"><a href="#3、创建目录" class="headerlink" title="3、创建目录"></a>3、创建目录</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir /share</span><br></pre></td></tr></table></figure>
<h4 id="4、修改配置文件"><a href="#4、修改配置文件" class="headerlink" title="4、修改配置文件"></a>4、修改配置文件</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi /etc/samba/smb.conf</span><br><span class="line">[global]</span><br><span class="line">			security = user</span><br><span class="line">			hosts allow=192.168.0.0/255.255.255.0</span><br><span class="line"></span><br><span class="line">[shore]</span><br><span class="line">			comment = share</span><br><span class="line">			path = /share</span><br><span class="line">			browseable = yes</span><br><span class="line">			writable = yes</span><br><span class="line">			valid users = @jsjuser,jsjuser</span><br></pre></td></tr></table></figure>
<h4 id="5、启动服务"><a href="#5、启动服务" class="headerlink" title="5、启动服务"></a>5、启动服务</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl restart smb</span><br></pre></td></tr></table></figure>
<h4 id="6、关闭防火墙、修改策略"><a href="#6、关闭防火墙、修改策略" class="headerlink" title="6、关闭防火墙、修改策略"></a>6、关闭防火墙、修改策略</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl  stop iptables#防火墙</span><br><span class="line">systemctl  stop firewalld#防火墙</span><br><span class="line">setenforce 0</span><br></pre></td></tr></table></figure>
<h4 id="7、挂载目录"><a href="#7、挂载目录" class="headerlink" title="7、挂载目录"></a>7、挂载目录</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mount //1.1.1.110/share /mnt -o username = smb1,password = liangwenxin</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">net use * /delete /y</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">comment---------注释说明</span><br><span class="line">path------------分享资源的完整路径名称，除了路径要正确外，目录的权限也要设对</span><br><span class="line">browseable------是yes/否no在浏览资源中显示共享目录，若为否则必须指定共享路径才能存取</span><br><span class="line">printable-------是yes/否no允许打印</span><br><span class="line">hide dot ftles--是yes/否no隐藏隐藏文件</span><br><span class="line">public----------是yes/否no公开共享，若为否则进行身份验证(只有当security = share 时此项才起作用)</span><br><span class="line">guest ok--------是yes/否no公开共享，若为否则进行身份验证(只有当security = share 时此项才起作用)</span><br><span class="line">read only-------是yes/否no以只读方式共享当与writable发生冲突时也writable为准</span><br><span class="line">writable--------是yes/否no不以只读方式共享当与read only发生冲突时，无视read only</span><br><span class="line">vaild users-----设定只有此名单内的用户才能访问共享资源(拒绝优先)(用户名/@组名)</span><br><span class="line">invalid users---设定只有此名单内的用户不能访问共享资源(拒绝优先)(用户名/@组名)</span><br><span class="line">read list-------设定此名单内的成员为只读(用户名/@组名)</span><br><span class="line">write list------若设定为只读时，则只有此设定的名单内的成员才可作写入动作(用户名/@组名)</span><br><span class="line">create mask-----建立文件时所给的权限</span><br><span class="line">directory mask--建立目录时所给的权限</span><br><span class="line">force group-----指定存取资源时须以此设定的群组使用者进入才能存取(用户名/@组名)</span><br><span class="line">force user------指定存取资源时须以此设定的使用者进入才能存取(用户名/@组名)</span><br><span class="line">allow hosts-----设定只有此网段/IP的用户才能访问共享资源</span><br><span class="line">allwo hosts = 网段 except IP</span><br><span class="line">deny hosts------设定只有此网段/IP的用户不能访问共享资源</span><br><span class="line">allow hosts=本网段指定IP指定IP</span><br><span class="line">deny hosts=指定IP本网段指定IP</span><br></pre></td></tr></table></figure>
<p><a href="https://blog.csdn.net/weixin_34390996/article/details/92980208?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener">https://blog.csdn.net/weixin_34390996/article/details/92980208?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task</a></p>
<p>1、FTp</p>
<p><a href="https://www.cnblogs.com/Wang352051443/p/9805980.html" target="_blank" rel="noopener">https://www.cnblogs.com/Wang352051443/p/9805980.html</a></p>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>linux-dns</title>
    <url>/2019/11/03/linux-dns/</url>
    <content><![CDATA[<p><a href="https://www.cnblogs.com/yueshang/p/9447456.html" target="_blank" rel="noopener">https://www.cnblogs.com/yueshang/p/9447456.html</a></p>
<p><a href="https://blog.csdn.net/weixin_33800593/article/details/92384884" target="_blank" rel="noopener">https://blog.csdn.net/weixin_33800593/article/details/92384884</a></p>
<h4 id="1、安装dns服务"><a href="#1、安装dns服务" class="headerlink" title="1、安装dns服务"></a>1、安装dns服务</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum list bind</span><br><span class="line">yum install bind.x86_64</span><br></pre></td></tr></table></figure>
<h4 id="2、编辑解析配置文件"><a href="#2、编辑解析配置文件" class="headerlink" title="2、编辑解析配置文件"></a>2、编辑解析配置文件</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi /etc/named.conf</span><br><span class="line">options &#123;</span><br><span class="line">listen-on port 53 &#123; 192.168.0.200&#125;; //改成自己服务器的IP</span><br><span class="line">listen-on-v6 port 53 &#123; ::1; &#125;;</span><br><span class="line">directory &quot;/var/named&quot;;</span><br><span class="line">dump-file &quot;/var/named/data/cache_dump.db&quot;;</span><br><span class="line">statistics-file &quot;/var/named/data/named_stats.txt&quot;;</span><br><span class="line">memstatistics-file &quot;/var/named/data/named_mem_stats.txt&quot;;</span><br><span class="line">allow-query &#123; any; &#125;; //任何人都可以访问 ###</span><br></pre></td></tr></table></figure>
<h4 id="3、配置区域解析文件"><a href="#3、配置区域解析文件" class="headerlink" title="3、配置区域解析文件"></a>3、配置区域解析文件</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi /etc/named.rfc1912.zones</span><br><span class="line">//正向区域配置</span><br><span class="line">zone &quot;lwx.com&quot; IN &#123;</span><br><span class="line">type master;</span><br><span class="line">file &quot;lwx.com.zone&quot;;</span><br><span class="line">allow-update &#123; none; &#125;;</span><br><span class="line">&#125;;</span><br><span class="line">//反向区域配置</span><br><span class="line">zone &quot;68.68.68.in-addr.arpa&quot; IN &#123;</span><br><span class="line">type master;</span><br><span class="line">file &quot;68.com.local&quot;;</span><br><span class="line">allow-update &#123; none; &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="4、编辑解析文件"><a href="#4、编辑解析文件" class="headerlink" title="4、编辑解析文件"></a>4、编辑解析文件</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd /var/named</span><br><span class="line">cp -p named.localhost lwx.com.zone</span><br><span class="line">修改配置内容：vi lwx.com.zone</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$TTL 1D</span><br><span class="line">@ IN SOA @ rname.invalid. (</span><br><span class="line">0 ; serial</span><br><span class="line">1D ; refresh</span><br><span class="line">1H ; retry</span><br><span class="line">1W ; expire</span><br><span class="line">3H ) ; minimum</span><br><span class="line">NS @</span><br><span class="line">A 192.168.0.220 //本服务器地址</span><br><span class="line">www IN A 68.68.68.168 //www.lwx.com对应的地址</span><br><span class="line">ftp IN A 68.68.68.68 //ftp.lwx.com对应的地址</span><br><span class="line">mail IN CNAME www</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cp  -p lwx.com.zone lwx.com.local</span><br><span class="line">vi hello.com.local</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$TTL 1D</span><br><span class="line">@ IN SOA lwx.com. rname.invalid. ( //此处@变量要修改成域名，注意最后面的“.”不能漏掉</span><br><span class="line">0 ; serial</span><br><span class="line">1D ; refresh</span><br><span class="line">1H ; retry</span><br><span class="line">1W ; expire</span><br><span class="line">3H ) ; minimum</span><br><span class="line">NS @</span><br><span class="line">A 192.168.80.10</span><br><span class="line">10 IN PTR www.lwx.com. //注意最后面的“.”不要漏掉</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">named-checkconf //检查语法错误</span><br></pre></td></tr></table></figure>
<h4 id="5、重新启动服务"><a href="#5、重新启动服务" class="headerlink" title="5、重新启动服务"></a>5、重新启动服务</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl restart named //重新启动</span><br><span class="line"></span><br><span class="line">netstat -anpu | grep name //查看服务运行状态</span><br></pre></td></tr></table></figure>
<h4 id="6、测试"><a href="#6、测试" class="headerlink" title="6、测试"></a>6、测试</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi /etc/resolv.conf //配置服务器DNS</span><br><span class="line"></span><br><span class="line">nslookup www.lwx.com //正向</span><br><span class="line">nslookup 68.68.68.168//反向</span><br></pre></td></tr></table></figure>
<h4 id="7、客户端测试关闭防火墙"><a href="#7、客户端测试关闭防火墙" class="headerlink" title="7、客户端测试关闭防火墙"></a>7、客户端测试关闭防火墙</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl stop firewalld //关闭防火墙</span><br><span class="line"></span><br><span class="line">systemctl stop iptables //关闭防火墙</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>linux--dhcp</title>
    <url>/2019/10/30/linux-dhcp/</url>
    <content><![CDATA[<h4 id="1、安装DHCP服务"><a href="#1、安装DHCP服务" class="headerlink" title="1、安装DHCP服务"></a>1、安装DHCP服务</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum list dhcp</span><br><span class="line">yum install dhcp.x86_64</span><br></pre></td></tr></table></figure>
<h4 id="2、配置DHCP服务器"><a href="#2、配置DHCP服务器" class="headerlink" title="2、配置DHCP服务器"></a>2、配置DHCP服务器</h4><p>1、拷贝示例文件覆盖原来的空文件。通过rpm -ql dhcp查看自己模板配置文件（不一定和我一样的版本）    </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cp /usr/share/doc/dhcp-4.2.5/dhcpd.conf.example /etc/dhcp/dhcpd.conf</span><br></pre></td></tr></table></figure>
<h4 id="3、编写DHCP文档"><a href="#3、编写DHCP文档" class="headerlink" title="3、编写DHCP文档"></a>3、编写DHCP文档</h4><p>修改配置文件/etc/dhcp/dhcpd.conf  如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">subnet 192.168.0.0  netmask 255.255.255.0 &#123;</span><br><span class="line">  range 192.168.0.100  192.168.0.200;                         ##地址池 </span><br><span class="line">  option domain-name-servers  192.168.0.2;                   ##DNS服务器地址     </span><br><span class="line">  option routers 192.168.0.1; 					           ##默认路由</span><br><span class="line">  option broadcast-address 192.168.0.255;                     ##广播地址</span><br><span class="line">  default-lease-time 86400;                                       ##默认租约时间 </span><br><span class="line">  max-lease-time 28800;                                          ##最大租约时间 </span><br><span class="line">&#125;</span><br><span class="line">host windows7 &#123;</span><br><span class="line">	hardware ethernet 00:0c:29:0f:67;</span><br><span class="line">	fixed-address 192.168.0.111;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dhcpd -t ##检查语法错误</span><br></pre></td></tr></table></figure>
<h4 id="4、重新启动DHCP服务"><a href="#4、重新启动DHCP服务" class="headerlink" title="4、重新启动DHCP服务"></a>4、重新启动DHCP服务</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl restart dhcpd.service #重新启动dhcp</span><br><span class="line"></span><br><span class="line">dhclient #重新获得地址</span><br></pre></td></tr></table></figure>
<p>servername 95</p>
<p>/var/www/html/index.html</p>
<p>119行</p>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>linux配置防火墙策略实验</title>
    <url>/2019/10/25/linux-firewalld-1/</url>
    <content><![CDATA[<p>1、开启防火墙<br>systemctl stats firewalld.service</p>
<p>2、设置防火墙默认区域为internal<br>firewall-cmd –set-default-zone=internal<br>查看防火墙默认区域<br>firewall-cmd –get-default-zone</p>
<p>3、设置防火墙活动区域为internal<br>firewall-cmd –permanent –change-interface=ens33 –zone=internal<br>查看防火墙默认活动区域<br>firewall-cmd –get-acitve-zone</p>
<p>4、移除ssh服务，添加富规则<br>查看防火墙规则<br>firewall-cmd –list-all<br>在规则里移除ssh服务<br>firewall-cmd –remove-service=ssh –permanent<br>添加富规则<br>firewall-cmd –permanent –zone=internal –add-rich-rules=”rule family=”ipv4 source address=”1.1.1.164” service name=”ssh” accept”<br>重新加载规则<br>firewall-cmd –reload</p>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>linux-----firewalld</title>
    <url>/2019/10/25/linux-firewalld/</url>
    <content><![CDATA[<h5 id="Centos7-systemctl-启动-firewalld-时出现-Failed-to-start-firewalld-service-Unit-is-masked"><a href="#Centos7-systemctl-启动-firewalld-时出现-Failed-to-start-firewalld-service-Unit-is-masked" class="headerlink" title="Centos7 systemctl 启动 firewalld 时出现 Failed to start firewalld.service: Unit is masked."></a>Centos7 systemctl 启动 firewalld 时出现 Failed to start firewalld.service: Unit is masked.</h5><p>也就是说这个命令被锁着了，只需要执行如下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl unmask firewalld</span><br></pre></td></tr></table></figure>
<p>出现下面提示即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Removed symlink /etc/systemd/system/firewalld.service</span><br></pre></td></tr></table></figure>
<p>如果啥时候想锁定他，执行下面命令即可：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl mask firewalld</span><br></pre></td></tr></table></figure>
<p>通过systemctl start firewalld开启防火墙，没有任何提示即开启成功。</p>
<p>再次通过systemctl status firewalld查看firewalld状态，显示running即已开启。</p>
<h4 id="redirecting-to-bin-systemctl-restart-sshd-service"><a href="#redirecting-to-bin-systemctl-restart-sshd-service" class="headerlink" title="redirecting to /bin/systemctl restart sshd.service"></a>redirecting to /bin/systemctl restart sshd.service</h4><p>查看 sshd 服务是否启动</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl status sshd.service</span><br></pre></td></tr></table></figure>
<p>启动该服务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl start sshd.service</span><br></pre></td></tr></table></figure>
<p>重启sshd服务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl restart sshd.service</span><br></pre></td></tr></table></figure>
<p>设置服务开启自启</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl enable sshd.service</span><br></pre></td></tr></table></figure>
<h4 id="查看linux-SSH服务常用命令"><a href="#查看linux-SSH服务常用命令" class="headerlink" title="查看linux SSH服务常用命令"></a>查看linux SSH服务常用命令</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rpm -qa | grep ssh</span><br></pre></td></tr></table></figure>
<p> 可以看到系统中ssh安装包   </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ps -ef | grep ssh</span><br></pre></td></tr></table></figure>
<p>查看ssh服务有没有运行,如果有,可以看到类似以下内容:<br>root 2659 1 0 18:31 ? 00:00:00 /usr/sbin/sshd<br>root 2702 2618 0 18:38 pts/0 00:00:00 grep ssh<br>这证明ssh已经在运行了,进程名为sshd<br>如果没有运行,可以通过以下命令运行之:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">service sshd start</span><br></pre></td></tr></table></figure>
<p>再看下这个ssh服务的网络连接情况:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">netstat -ntlp</span><br></pre></td></tr></table></figure>
<p>如果看到如下内容:<br>tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN<br>这说明sshd已经能够正常工作了,如果利用客户端(SecurCRT,putty等)连接不上,尝试关闭防火墙试试: service iptables stop</p>
<h4 id="配置虚拟机网络"><a href="#配置虚拟机网络" class="headerlink" title="配置虚拟机网络"></a>配置虚拟机网络</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi /etc/sysconfig/networf-scripts/ifcfg-ens33</span><br></pre></td></tr></table></figure>
<p>配置与主机相同网段的IP地址、子网掩码、网关信息</p>
<p>重启网卡</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">service network restart</span><br></pre></td></tr></table></figure>
<h4 id="使用systemctl-restart-network无法重启网络和ping不通百度"><a href="#使用systemctl-restart-network无法重启网络和ping不通百度" class="headerlink" title="使用systemctl restart network无法重启网络和ping不通百度"></a>使用systemctl restart network无法重启网络和ping不通百度</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl stop NetworkManager.service </span><br><span class="line">systemctl disable NetworkManager.service</span><br></pre></td></tr></table></figure>
<p>停止网络管理服务</p>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>linux基本操作</title>
    <url>/2019/09/06/linux/</url>
    <content><![CDATA[<h4 id="1、查看文档信息"><a href="#1、查看文档信息" class="headerlink" title="1、查看文档信息"></a>1、查看文档信息</h4><p>我们要查看一些文本文件的内容时，要使用文本编辑器来查看。在Linux下，可以使用一些命令预览文本文件中的内容，而不必使用文本编辑器打开查看。这篇笔记分享几个常用的文本查看命令。分别是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat：从第一行开始显示文本内容（适用于内容较少的）</span><br><span class="line">tac：从最后一行开始显示，是 cat 的逆顺序</span><br><span class="line">more：一页一页的显示文本内容（适用于内容较多的）</span><br><span class="line">less：与 more 类似，但是比 more 更好的是，它可以往前翻页！</span><br><span class="line">head：只看文本的前面几行</span><br><span class="line">tail：只看文本的后面几行</span><br><span class="line">nl：显示文本内容与行号</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grep -v &quot;^#&quot;     ###查看非注释文件</span><br></pre></td></tr></table></figure>
<h4 id="2、挂载光盘"><a href="#2、挂载光盘" class="headerlink" title="2、挂载光盘"></a>2、挂载光盘</h4><p>1、找到光盘的完整路径名。在命令行输入：ls -l /dev | grep cdrom。<br>2、可以看到光盘的名字叫做：cdrom。然后在命令行执行： mount /dev/cdrom /mnt/。这会把光盘挂载到/mnt目录下。然后我们就可以通过访问/mnt来访问光盘。<br>3、比如我们要从光盘中拷贝出来一个rpm包。首先在命令行输入：cd /mnt。然后输入ll。就列出了光盘里面的所有的内容。<br>4、进入到Packages目录，在命令行输入：cd Packages。然后输入：ls -l | grep mysql。找到我们要拷贝出来的rpm包。<br>5、在命令行输入： cp mysql-5.1.66-2.el6_3.x86_64.rpm /opt/soft。把mysql-5.1.66-2.el6_3.x86_64.rpm这个包拷贝到/opt/soft目录下面。在命令行输入：cd /opt/soft。然后ll。可以看到文件已经被拷贝过去了。<br>6、使用完毕以后，要记得卸载光盘。在命令行输入：umount /mnt。然后再进入/mnt目录就看不到光盘的内容了，说明已经成功卸载。</p>
<p>这个时候，会出现一个问题：mount: block device /dev/sr0 is write-protected, mounting read-only<br>提示信息说，虚拟机挂着光驱光驱时提示只读。用以下命令可解决该报错：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mount -o remount,rw /dev/cdrom /mnt</span><br></pre></td></tr></table></figure>
<p><a href="https://blog.csdn.net/qq_42776455/article/details/84066933" target="_blank" rel="noopener">https://blog.csdn.net/qq_42776455/article/details/84066933</a></p>
<p><a href="https://www.cnblogs.com/chris-cp/p/4843407.html" target="_blank" rel="noopener">https://www.cnblogs.com/chris-cp/p/4843407.html</a></p>
<p>3、安装报错NO <strong>*</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install epel-release //安装专业版软件库</span><br></pre></td></tr></table></figure>
<p>4、查看本地安装的服务</p>
<p>rpm -qa | grep ***</p>
<p><a href="https://www.cnblogs.com/Wang352051443/p/9805980.html" target="_blank" rel="noopener">https://www.cnblogs.com/Wang352051443/p/9805980.html</a></p>
<p>5、查看本地用户、用户组</p>
<p>cat /etc/passwd<br>cat /etc/group</p>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机组成原理---总线的基本概念</title>
    <url>/2019/08/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/</url>
    <content><![CDATA[<p><strong>0x01 总线的基本概念</strong><br>1.总线是链接各个部件的信息传输线、是各个部件共享的传输介质（一条总线只能被一个设备使用、占用了就要通信）<br>2.总线上信息的传送：穿行、并行<br>备注：并行线路无法用于长距离通信、并行传输线路成本高（很宽的一根线，如PATA）信号线之间的干扰大，不能用于长距离传输。在并行传输中，如果传输频率高，数据线之间会产生很大的干扰。串行传输分为：异步传输、同步传输、等时传输。异步传输是面向字符的传输，同步传输是面向比特的传输。异步传输的单位是字符而同步传输的单位是帧，异步传输通过字符起止的开始和停止码抓住在同步的机会，而同步传输则是以数据中抽取同步信息。在实际形况中串行要比并行速度快。</p>
<p><strong>0x02 总线的分类</strong><br>1.片内总线：芯片内的总线<br>2.系统总线：计算机各个部件的信息传输线<br>数据总线：双向、与机器字长、存储字长有关<br>地址总线：单向、与存储地址、I/O地址有关<br>控制总线：有出、有入<br>3.通信总线：用于计算机系统直线或计算机与其他系统（如控制仪表、移动通信等）之间的通信<br>传输方式：串行、并行</p>
<p><strong>0x03 总线的特性</strong><br>1.机械特性：尺寸、形状、管脚数以及排列顺序<br>2.电气特性：传输方向和有效的电平范围（高电平表示1、低电平表示0）<br>3.功能特性：每根传输线的功能（地址、数据、控制信号）<br>4.时间特性：信号的时序关系</p>
<p><strong>0x04 总线的性能指标</strong><br>1.总线的宽度：数据线的根数（4、8、16、32）<br>2.标准传输率：每秒传输的最大字节数（MBps）<br>3.时钟同步/异步：同步、不同步<br>4.总线复用：地址线与数据线复用（公用、8086地址线与数据线共用）<br>5.信号线数：地址线、数据线和控制线的总和<br>6.总线控制方式：图发、自动、仲裁、逻辑、计数<br>7.其他指标：负载 能力</p>
<p><strong>0x05 总结机构</strong><br>1.单总线结构：系统总线<br>2.双总线结构：主存总线（CPU、主存、通道）、I/O总线（I/O接口、设备）<br>3.三总线结构1：主存总线（CPU与主存）、I/O总线（CPU与I/O接口）、DMA总线（高速外设与主存）<br>4.三总线结构2：局部总线（CPU与Cache、局部I/O控制器）、系统总线（主存、Cache、扩展总线接口）、扩展总线（局域网、SCSI、扩展总线接口、MOdem、串行接口）<br>5.四总线结构：局部总线（CPU与Cache桥）、系统总线（Cache、主存）、高速总线（高速设备：SCSI、图形、Cache桥、多媒体、局域网）、扩展总线（低速设备：FAX、扩展总线接口、Modem、串行接口）<br>备注：最新的设备通过总线将高速设备与低速设备分离、系统总线连接CPU与存储器。CPU与Memory一条线、高速设备一条线、低速设备一条线。北桥控制CPU、内存、显卡和PCI交换数据，南桥控制IO设备。</p>
<p><strong>0x06 总线控制</strong><br>1、总线判优控制：<br>主设备：对总线有控制权<br>从设备：响应从主设备发来的总线命令<br>总线判优控制：集中式（链式查询、计数器定时查询、独立请求方式）、分布式</p>
]]></content>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机组成原理1</title>
    <url>/2019/08/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%861/</url>
    <content><![CDATA[<p><strong>0x01 计算机体系系统结构</strong><br>软件和硬件</p>
<p><strong>0x02 计算机系统组成</strong><br>运算器、控制器</p>
<p><strong>0x03 计算机系统的层次结构</strong><br>高级语言-&gt;汇编语言-&gt;操作系统-&gt;机器语言-&gt;微指令系统<br>虚拟机器M4：用编译程序翻译成汇编语言程序<br>虚拟机器M3：用汇编程序翻译成机器语言程序<br>虚拟机器M2：用机器语言解释操作系统<br>实际机器M1：用微指令解释机器指令<br>微程序机器M0：由硬件直接执行微指令<br>备注：M4、M3、M2由软件实现M1、M0由硬件实现</p>
<p><strong>0x04 计算机体系结构与计算机组成的区别</strong><br>计算机体系结构：程序员所见到的计算机系统的属性概念性的结构与功能特性（指令系统、数据类型、寻址技术、I/O机理）架构<br>计算机组成：实现计算机体系结构所见的属性（具体指令的实现）执行者</p>
<p><strong>0x05 计算机得基本组成</strong><br>冯诺依曼计算机的特点<br>1.计算机由五大部件组成<br>2.指令和数据以同等地位存于存储器、可以按照地址寻访<br>3.指令和数据用二进制表示<br>4.指令由操作码和地址码组成<br><u>5.存储程序</u><br>6.以运算器为中心（核心） </p>
<p><strong>0x06 主机的基本组成</strong><br>1.主存储器：存储体、MAR（存储器地址寄存器）、MDR（存储器数据寄存器）<br>存储体-存储单元-存储元件<br><em>存储单元：存放一串二进制代码</em><br><em>存储字：存储单元中二进制代码的组合</em><br><em>存储字长：存储单元中二进制代码的</em><br>MAR（存储器地址寄存器）：反应存储单元的个数<br>MDR（存储器数据寄存器）：反应存储字长<br>备注：以二进制的形式存储、可以按照地址访问、指令有操作码和地址码<br>2.运算器：ACC（累加器）、ALU（算数逻辑单元）、MQ（乘商寄存器）、X（操作数寄存器）<br>3.控制器：PC（程序计数器）、IR（指令寄存器）、<u>CU（控制单元）</u><br>PC（程序计数器）：存放当前欲执行的指令的地址、具有计数功能<br>IR（指令寄存器）：存放当前欲执行的指令<br>4.I/O设备</p>
<p><strong>0x07 指令的运行过程</strong><br>1.取数指令操作：PC-&gt;MAR-&gt;存储体-&gt;MDR-&gt;IR-&gt;CU—IR-&gt;MAR-&gt;存储体-&gt;MDR-&gt;ACC<br>2.存数指令操作：PC-&gt;MAR-&gt;存储体-&gt;MDR-&gt;IR-&gt;CU—IR-&gt;MAR-&gt;存储体—ACC-&gt;MDR<br>3.ax2+bx+c程序的运行过程<br>将程序通过输入设备送至计算机<br>程序首地址-&gt;PC<br>启动程序运行<br>取指令PC-&gt;MAR-&gt;存储体-&gt;MDR-&gt;IR<br>分析指令OP（IR）-&gt;CU<br>执行指令AD（IR）-&gt;MAR-&gt;存储体-&gt;-&gt;MDR-&gt;ACC</p>
]]></content>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>python爬虫解析库</title>
    <url>/2019/08/05/python-1/</url>
    <content><![CDATA[<p><strong>Urllib</strong></p>
<p>Python内置的Http请求库<br>urllib.request 请求模块<br>urllib.error 异常处理模块<br>urllib.parse url解析模块<br>urllib.robotparser robots.txt解析模块</p>
<p><strong>获取百度源代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"></span><br><span class="line">re = urllib.request.urlopen(<span class="string">"http://www.baidu.com"</span>)</span><br><span class="line">print(re.read().decode(<span class="string">'utf-8'</span>))</span><br></pre></td></tr></table></figure>
<p><strong>Requests</strong></p>
<p><strong>异常处理</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> requests.exceptions <span class="keyword">import</span> ReadTimeout</span><br><span class="line"></span><br><span class="line">URL = <span class="string">"http://httpbin.org/get"</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">	response = requests.get(URL,timeout = <span class="number">0.01</span>)</span><br><span class="line">	print(response.status_code)</span><br><span class="line"><span class="keyword">except</span> ReadTimeout:</span><br><span class="line">	print(<span class="string">"Timeout"</span>)</span><br></pre></td></tr></table></figure>
<p><strong>正则表达式</strong></p>
<p><img src="/2019/08/05/python-1/H:/hexo\blog\myblog\source\_posts\python-1\正则表达式.jpg" alt></p>
<p>re.match</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">content = <span class="string">"Hello 123 4567 World_This is a Regex Demo"</span></span><br><span class="line">result = re.match(<span class="string">'^Hello\s\d\d\d\s\d&#123;4&#125;\s\w&#123;10&#125;.*Demo$'</span>,content)</span><br><span class="line">print(result) </span><br><span class="line">print(result.group()) <span class="comment">#输出结果</span></span><br><span class="line">print(result.span()) <span class="comment">#输出范围</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">content = <span class="string">"Hello 1234567 World_This is a Regex Demo"</span></span><br><span class="line">result = re.match(<span class="string">'^.*?(\d+).*$'</span>,content) <span class="comment">#非贪婪匹配</span></span><br><span class="line">result = re.match(<span class="string">'^.*(\d+).*$'</span>,content) <span class="comment">#贪婪匹配</span></span><br><span class="line"></span><br><span class="line">print(result) </span><br><span class="line">print(result.group(<span class="number">1</span>))</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">content = <span class="string">'''Hello 1234567 World_This </span></span><br><span class="line"><span class="string">is a Regex Demo'''</span></span><br><span class="line"></span><br><span class="line">result = re.match(<span class="string">'^.*?(\d+).*$'</span>,content,re.S)</span><br><span class="line"><span class="comment">#匹配换行re.s</span></span><br><span class="line"></span><br><span class="line">print(result) </span><br><span class="line">print(result.group())</span><br></pre></td></tr></table></figure>
<p>总结：尽量使用反匹配、使用括号得到匹配目标、尽量使用非贪婪模式、有换行符就用re.s</p>
<p>re.search</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">content = <span class="string">'Extra stings Hello 1234567 World_This is a Regex Demo Extra strings'</span></span><br><span class="line">result = re.search(<span class="string">'Hello.*?(\d+).*?Demo'</span>,content)</span><br><span class="line"></span><br><span class="line">print(result) </span><br><span class="line">print(result.group())</span><br></pre></td></tr></table></figure>
<p>总结：为匹配方便，能用search就不用match</p>
<p>html测试</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">content = <span class="string">'''&lt;li data-view = "4" class="active"&gt;</span></span><br><span class="line"><span class="string">				&lt;a href="/3.mp3" singer="齐秦"&gt;往事随风&lt;/a&gt;</span></span><br><span class="line"><span class="string">				&lt;/li&gt;	'''</span></span><br><span class="line">result = re.search(<span class="string">'&lt;li.*?singer="(.*?)"&gt;(.*?)&lt;/a&gt;'</span>,content,re.S)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> result: </span><br><span class="line">	print(result.group(<span class="number">1</span>),result.group(<span class="number">2</span>))</span><br></pre></td></tr></table></figure>
<p>re.findall</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">content = <span class="string">'''   &lt;li data-view = "4" class="active"&gt;</span></span><br><span class="line"><span class="string">				&lt;a href="/3.mp3" singer="齐秦"&gt;往事随风&lt;/a&gt;</span></span><br><span class="line"><span class="string">				&lt;/li&gt;	</span></span><br><span class="line"><span class="string">				&lt;li data-view = "4" class="active"&gt;</span></span><br><span class="line"><span class="string">				&lt;a href="/3.mp3" singer="陈奕迅"&gt;十年&lt;/a&gt;</span></span><br><span class="line"><span class="string">				&lt;/li&gt;	</span></span><br><span class="line"><span class="string">				&lt;li data-view = "4" class="active"&gt;</span></span><br><span class="line"><span class="string">				&lt;a href="/3.mp3" singer="梁文鑫"&gt;再见&lt;/a&gt;</span></span><br><span class="line"><span class="string">				&lt;/li&gt;	</span></span><br><span class="line"><span class="string">				&lt;li data-view = "4" class="active"&gt;</span></span><br><span class="line"><span class="string">				&lt;a href="/3.mp3" singer="邓丽君"&gt;但愿人长久&lt;/a&gt;</span></span><br><span class="line"><span class="string">				&lt;/li&gt;	</span></span><br><span class="line"><span class="string">								</span></span><br><span class="line"><span class="string">			'''</span></span><br><span class="line"></span><br><span class="line">results = re.findall (<span class="string">'&lt;li.*?singer="(.*?)"&gt;(.*?)&lt;/a&gt;'</span>,content,re.S)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> result <span class="keyword">in</span> results:</span><br><span class="line">	print(result[<span class="number">0</span>],result[<span class="number">1</span>])</span><br></pre></td></tr></table></figure>
<p>总结：查找符合所有符合的信息</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">content =requests.get(<span class="string">'https://book.douban.com'</span>).text</span><br><span class="line">pattern = re.compile(<span class="string">'&lt;li.*?cover.*?href="(.*?)".*?title="(.*?)".*?mort-meta.*?author"&gt;(.*?)&lt;/span&gt;.*?year"&gt;(.*?)&lt;/span&gt;.*?&lt;/li&gt;'</span>,re.S)</span><br><span class="line"></span><br><span class="line">results = re.findall(pattern,content)</span><br><span class="line">print(results)</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python爬虫基本知识</title>
    <url>/2019/08/05/python/</url>
    <content><![CDATA[<p><strong>python爬虫获取网页信息</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">headers = &#123;<span class="string">'User-Agent'</span>:<span class="string">'Mozilla/5.0 (iPad; CPU OS 11_0 like Mac OS X) AppleWebKit/604.1.34 (KHTML, like Gecko) Version/11.0 Mobile/15A5341f Safari/604.1'</span>&#125;</span><br><span class="line">response = requests.get(<span class="string">"http://www.baidu.com"</span>,headers = headers)</span><br><span class="line"></span><br><span class="line">print(response.text) </span><br><span class="line">print(response.headers)</span><br><span class="line">print(response.content) <span class="comment">#获取二进制信息 </span></span><br><span class="line">print(response.status_code)</span><br></pre></td></tr></table></figure>
<p><strong>将网页图片保存到本地（图片、视频、文档使用二进制方式）</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">URL = <span class="string">"https://ss0.bdstatic.com/k4oZeXSm1A5BphGlnYG/pad/hd/sidenavicon/news.png"</span></span><br><span class="line">headers = &#123;<span class="string">'User-Agent'</span>:<span class="string">'Mozilla/5.0 (iPad; CPU OS 11_0 like Mac OS X) AppleWebKit/604.1.34 (KHTML, like Gecko) Version/11.0 Mobile/15A5341f Safari/604.1'</span>&#125;</span><br><span class="line"></span><br><span class="line">response = requests.get(URL,headers = headers)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'h:/1/1.png'</span>,<span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">	f.write(response.content)</span><br><span class="line">	f.close()</span><br></pre></td></tr></table></figure>
<p><strong>数据提取方式：直接处理、Json解析、正则表达式、解析库BeautifulSoup</strong></p>
<p><strong>解决JavaScript渲染问题(模拟js渲染)Selenium/Webdriver、Splash、Pyv8、Ghost.py</strong></p>
<p><strong>从本地Chrome浏览器进入百度</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver </span><br><span class="line"></span><br><span class="line">driver = webdriver.Chrome()  </span><br><span class="line">driver.get(<span class="string">'https://www.baidu.com'</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP的三次握手与四次挥手理解</title>
    <url>/2019/07/22/TCP-IP%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<p><strong>TCP的三次握手与四次挥手理解</strong></p>
<p><img src="/2019/07/22/TCP-IP协议/H:/hexo\blog\myblog\source\_posts\TCP-IP协议\1.jpg" alt></p>
<p>序列号seq：占4个字节，用来标记数据段的顺序，TCP把连接中发送的所有数据字节都编上一个序号，第一个字节的编号由本地随机产生；给字节编上序号后，就给每一个报文段指派一个序号；序列号seq就是这个报文段中的第一个字节的数据编号。</p>
<p> 确认号ack：占4个字节，期待收到对方下一个报文段的第一个数据字节的序号；序列号表示报文段携带数据的第一个字节的编号；而确认号指的是期望接收到下一个字节的编号；因此当前报文段最后一个字节的编号+1即为确认号。</p>
<p>确认ACK：占1位，仅当ACK=1时，确认号字段才有效。ACK=0时，确认号无效。</p>
<p> 同步SYN：连接建立时用于同步序号。当SYN=1，ACK=0时表示：这是一个连接请求报文段。若同意连接，则在响应报文段中使得SYN=1，ACK=1。因此，SYN=1表示这是一个连接请求，或连接接受报文。SYN这个标志位只有在TCP建产连接时才会被置1，握手完成后SYN标志位被置0。</p>
<p> 终止FIN：用来释放一个连接。FIN=1表示：此报文段的发送方的数据已经发送完毕，并要求释放运输连接</p>
<p>PS：ACK、SYN和FIN这些大写的单词表示标志位，其值要么是1，要么是0；ack、seq小写的单词表示序号。</p>
<p>字段    含义<br>URG    紧急指针是否有效。为1，表示某一位需要被优先处理<br>ACK    确认号是否有效，一般置为1。<br>PSH    提示接收端应用程序立即从TCP缓冲区把数据读走。<br>RST    对方要求重新建立连接，复位。<br>SYN    请求建立连接，并在其序列号的字段进行序列号的初始值设定。建立连接，设置为1<br>FIN        希望断开连接。</p>
<p><strong>三次握手过程理解</strong></p>
<p><img src="/2019/07/22/TCP-IP协议/H:/hexo\blog\myblog\source\_posts\TCP-IP协议\20180717202520531.png" alt></p>
<p>第一次握手：建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。</p>
<p>第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；</p>
<p>第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。</p>
<p><strong>四次挥手过程理解</strong></p>
<p><img src="/2019/07/22/TCP-IP协议/H:/hexo\blog\myblog\source\_posts\TCP-IP协议\3.png" alt="四次握手"> </p>
<p>1）客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。<br>2）服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。<br>3）客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。<br>4）服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。<br>5）客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。</p>
<p>6）服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。</p>
<p>常见面试题<br>【问题1】为什么连接的时候是三次握手，关闭的时候却是四次握手？</p>
<p>答：因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，”你发的FIN报文我收到了”。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。</p>
<p>【问题2】为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？</p>
<p>答：虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。在Client发送出最后的ACK回复，但该ACK可能丢失。Server如果没有收到ACK，将不断重复发送FIN片段。所以Client不能立即关闭，它必须确认Server接收到了该ACK。Client会在发送出ACK之后进入到TIME_WAIT状态。Client会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么Client会重发ACK并再次等待2MSL。所谓的2MSL是两倍的MSL(Maximum Segment Lifetime)。MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。</p>
<p>【问题3】为什么不能用两次握手进行连接？</p>
<p>答：3次握手完成两个重要的功能，既要双方做好发送数据的准备工作(双方都知道彼此已准备好)，也要允许双方就初始序列号进行协商，这个序列号在握手过程中被发送和确认。</p>
<p>   现在把三次握手改成仅需要两次握手，死锁是可能发生的。作为例子，考虑计算机S和C之间的通信，假定C给S发送一个连接请求分组，S收到了这个分组，并发 送了确认应答分组。按照两次握手的协定，S认为连接已经成功地建立了，可以开始发送数据分组。可是，C在S的应答分组在传输中被丢失的情况下，将不知道S 是否已准备好，不知道S建立什么样的序列号，C甚至怀疑S是否收到自己的连接请求分组。在这种情况下，C认为连接还未建立成功，将忽略S发来的任何数据分 组，只等待连接确认应答分组。而S在发出的分组超时后，重复发送同样的分组。这样就形成了死锁。</p>
<p>【问题4】如果已经建立了连接，但是客户端突然出现故障了怎么办？</p>
<p>TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</p>
]]></content>
      <tags>
        <tag>WEB</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP协议</title>
    <url>/2019/07/21/HTTP%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<p><strong>一、HTTP协议详解之URL篇</strong></p>
<p>http（超文本传输协议）是一个基于请求与响应模式的、无状态的、应用层的协议，常基于TCP的连接方式，HTTP1.1版本中给出一种持续连接的机制，绝大多数的Web开发，都是构建在HTTP协议之上的Web应用。</p>
<p>http表示要通过HTTP协议来定位网络资源；host表示合法的Internet主机域名或者IP地址；port指定一个端口号，为空则使用缺省端口80；abs_path指定请求资源的URI；如果URL中没有给出abs_path，那么当它作为请求URI时，必须以“/”的形式给出，通常这个工作浏览器自动帮我们完成。</p>
<p>eg:<br>1、输入：<a href="http://www.guet.edu.cn/" target="_blank" rel="noopener">www.guet.edu.cn</a><br>浏览器自动转换成：<a href="http://www.guet.edu.cn/" target="_blank" rel="noopener">http://www.guet.edu.cn/</a><br>2、http:192.168.0.116:8080/index.jsp </p>
<p><strong>二、HTTP协议详解之请求篇</strong></p>
<p>http请求由三部分组成，分别是：请求行、消息报头、请求正文</p>
<p>请求行以一个方法符号开头，以空格分开，后面跟着请求的URI和协议的版本，格式如下：Method Request-URI HTTP-Version CRLF<br>其中 Method表示请求方法；Request-URI是一个统一资源标识符；HTTP-Version表示请求的HTTP协议版本；CRLF表示回车和换行（除了作为结尾的CRLF外，不允许出现单独的CR或LF字符）。</p>
<p>请求方法（所有方法全为大写）有多种，各个方法的解释如下：<br>GET     请求获取Request-URI所标识的资源<br>POST    在Request-URI所标识的资源后附加新的数据<br>HEAD    请求获取由Request-URI所标识的资源的响应消息报头<br>PUT     请求服务器存储一个资源，并用Request-URI作为其标识<br>DELETE  请求服务器删除Request-URI所标识的资源<br>TRACE   请求服务器回送收到的请求信息，主要用于测试或诊断<br>CONNECT 保留将来使用<br>OPTIONS 请求查询服务器的性能，或者查询与资源相关的选项和需求<br>应用举例：<br>GET方法：在浏览器的地址栏中输入网址的方式访问网页时，浏览器采用GET方法向服务器获取资源，eg:GET /form.html HTTP/1.1 (CRLF)</p>
<p>POST方法要求被请求服务器接受附在请求后面的数据，常用于提交表单。<br>eg：POST /reg.jsp HTTP/ (CRLF)<br>Accept:image/gif,image/x-xbit,… (CRLF)<br>…<br>HOST:<a href="http://www.guet.edu.cn" target="_blank" rel="noopener">www.guet.edu.cn</a> (CRLF)<br>Content-Length:22 (CRLF)<br>Connection:Keep-Alive (CRLF)<br>Cache-Control:no-cache (CRLF)<br>(CRLF)         //该CRLF表示消息报头已经结束，在此之前为消息报头<br>user=jeffrey&amp;pwd=1234  //此行以下为提交的数据</p>
<p>HEAD方法与GET方法几乎是一样的，对于HEAD请求的回应部分来说，它的HTTP头部中包含的信息与通过GET请求所得到的信息是相同的。利用这个方法，不必传输整个资源内容，就可以得到Request-URI所标识的资源的信息。该方法常用于测试超链接的有效性，是否可以访问，以及最近是否更新。</p>
<p><strong>三、HTTP协议详解之响应篇</strong></p>
<p>在接收和解释请求消息后，服务器返回一个HTTP响应消息。</p>
<p>HTTP响应也是由三个部分组成，分别是：状态行、消息报头、响应正文<br> 状态行格式如下：<br>HTTP-Version Status-Code Reason-Phrase CRLF<br>其中，HTTP-Version表示服务器HTTP协议的版本；Status-Code表示服务器发回的响应状态代码；Reason-Phrase表示状态代码的文本描述。<br>状态代码有三位数字组成，第一个数字定义了响应的类别，且有五种可能取值：<br>1xx：指示信息–表示请求已接收，继续处理<br>2xx：成功–表示请求已被成功接收、理解、接受<br>3xx：重定向–要完成请求必须进行更进一步的操作<br>4xx：客户端错误–请求有语法错误或请求无法实现<br>5xx：服务器端错误–服务器未能实现合法的请求<br>常见状态代码、状态描述、说明：</p>
<p>200：客户端请求成功，常见状态。<br>302：重定向。<br>404：请求资源不存在，常见状态。<br>400：客户端请求有语法错误，不能被服务器理解。<br>401：请求未经授权。<br>403：服务器收到请求，但是拒绝提供服务。<br>500：服务器内部错误，常见状态。<br>503：服务器当前不能处理客户端的请求，一段时间后可能恢复正常。</p>
<p>200 OK      //客户端请求成功<br>400 Bad Request  //客户端请求有语法错误，不能被服务器所理解<br>401 Unauthorized //请求未经授权，这个状态代码必须和WWW-Authenticate报                 //头域一起使用<br>403 Forbidden  //服务器收到请求，但是拒绝提供服务<br>404 Not Found  //请求资源不存在，eg：输入了错误的URL<br>500 Internal Server Error //服务器发生不可预期的错误<br>503 Server Unavailable  //服务器当前不能处理客户端的请求，一段时间后，                         //可能恢复正常</p>
<p><strong>四、HTTP协议详解之消息报头篇</strong></p>
<p>HTTP消息由客户端到服务器的请求和服务器到客户端的响应组成。请求消息和响应消息都是由开始行（对于请求消息，开始行就是请求行，对于响应消息，开始行就是状态行），消息报头（可选），空行（只有CRLF的行），消息正文（可选）组成。</p>
<p>HTTP消息报头包括普通报头、请求报头、响应报头、实体报头。<br>每一个报头域都是由名字+“：”+空格+值 组成，消息报头域的名字是大小写无关的。</p>
<p>1、普通报头<br>在普通报头中，有少数报头域用于所有的请求和响应消息，但并不用于被传输的实体，只用于传输的消息。<br>eg：<br>Cache-Control   用于指定缓存指令，缓存指令是单向的（响应中出现的缓存指令在请求中未必会出现），且是独立的（一个消息的缓存指令不会影响另一个消息处理的缓存机制），HTTP1.0使用的类似的报头域为Pragma。<br>请求时的缓存指令包括：no-cache（用于指示请求或响应消息不能缓存）、no-store、max-age、max-stale、min-fresh、only-if-cached;<br>响应时的缓存指令包括：public、private、no-cache、no-store、no-transform、must-revalidate、proxy-revalidate、max-age、s-maxage.<br>eg：为了指示IE浏览器（客户端）不要缓存页面，服务器端的JSP程序可以编写如下：response.sehHeader(“Cache-Control”,”no-cache”);<br>//response.setHeader(“Pragma”,”no-cache”);作用相当于上述代码，通常两者//合用<br>这句代码将在发送的响应消息中设置普通报头域：Cache-Control:no-cache</p>
<p>Date普通报头域表示消息产生的日期和时间</p>
<p>Connection普通报头域允许发送指定连接的选项。例如指定连接是连续，或者指定“close”选项，通知服务器，在响应完成后，关闭连接</p>
<p>2、请求报头<br>请求报头允许客户端向服务器端传递请求的附加信息以及客户端自身的信息。<br>常用的请求报头<br>Accept<br>Accept请求报头域用于指定客户端接受哪些类型的信息。eg：Accept：image/gif，表明客户端希望接受GIF图象格式的资源；Accept：text/html，表明客户端希望接受html文本。<br>Accept-Charset<br>Accept-Charset请求报头域用于指定客户端接受的字符集。eg：Accept-Charset:iso-8859-1,gb2312.如果在请求消息中没有设置这个域，缺省是任何字符集都可以接受。<br>Accept-Encoding<br>Accept-Encoding请求报头域类似于Accept，但是它是用于指定可接受的内容编码。eg：Accept-Encoding:gzip.deflate.如果请求消息中没有设置这个域服务器假定客户端对各种内容编码都可以接受。<br>Accept-Language<br>Accept-Language请求报头域类似于Accept，但是它是用于指定一种自然语言。eg：Accept-Language:zh-cn.如果请求消息中没有设置这个报头域，服务器假定客户端对各种语言都可以接受。<br>Authorization<br>Authorization请求报头域主要用于证明客户端有权查看某个资源。当浏览器访问一个页面时，如果收到服务器的响应代码为401（未授权），可以发送一个包含Authorization请求报头域的请求，要求服务器对其进行验证。<br>Host（发送请求时，该报头域是必需的）<br>Host请求报头域主要用于指定被请求资源的Internet主机和端口号，它通常从HTTP URL中提取出来的，eg：<br>我们在浏览器中输入：<a href="http://www.guet.edu.cn/index.html" target="_blank" rel="noopener">http://www.guet.edu.cn/index.html</a><br>浏览器发送的请求消息中，就会包含Host请求报头域，如下：<br>Host：<a href="http://www.guet.edu.cn" target="_blank" rel="noopener">www.guet.edu.cn</a><br>此处使用缺省端口号80，若指定了端口号，则变成：Host：<a href="http://www.guet.edu.cn:指定端口号" target="_blank" rel="noopener">www.guet.edu.cn:指定端口号</a><br>User-Agent<br>我们上网登陆论坛的时候，往往会看到一些欢迎信息，其中列出了你的操作系统的名称和版本，你所使用的浏览器的名称和版本，这往往让很多人感到很神奇，实际上，服务器应用程序就是从User-Agent这个请求报头域中获取到这些信息。User-Agent请求报头域允许客户端将它的操作系统、浏览器和其它属性告诉服务器。不过，这个报头域不是必需的，如果我们自己编写一个浏览器，不使用User-Agent请求报头域，那么服务器端就无法得知我们的信息了。<br>请求报头举例：<br>GET /form.html HTTP/1.1 (CRLF)<br>Accept:image/gif,image/x-xbitmap,image/jpeg,application/x-shockwave-flash,application/vnd.ms-excel,application/vnd.ms-powerpoint,application/msword,<em>/</em> (CRLF)<br>Accept-Language:zh-cn (CRLF)<br>Accept-Encoding:gzip,deflate (CRLF)<br>If-Modified-Since:Wed,05 Jan 2007 11:21:25 GMT (CRLF)<br>If-None-Match:W/“80b1a4c018f3c41:8317” (CRLF)<br>User-Agent:Mozilla/4.0(compatible;MSIE6.0;Windows NT 5.0) (CRLF)<br>Host:<a href="http://www.guet.edu.cn" target="_blank" rel="noopener">www.guet.edu.cn</a> (CRLF)<br>Connection:Keep-Alive (CRLF)<br>(CRLF)</p>
<p>3、响应报头<br>响应报头允许服务器传递不能放在状态行中的附加响应信息，以及关于服务器的信息和对Request-URI所标识的资源进行下一步访问的信息。<br>常用的响应报头<br>Location<br>Location响应报头域用于重定向接受者到一个新的位置。Location响应报头域常用在更换域名的时候。<br>Server<br>Server响应报头域包含了服务器用来处理请求的软件信息。与User-Agent请求报头域是相对应的。下面是<br>Server响应报头域的一个例子：<br>Server：Apache-Coyote/1.1<br>WWW-Authenticate<br>WWW-Authenticate响应报头域必须被包含在401（未授权的）响应消息中，客户端收到401响应消息时候，并发送Authorization报头域请求服务器对其进行验证时，服务端响应报头就包含该报头域。<br>eg：WWW-Authenticate:Basic realm=”Basic Auth Test!”  //可以看出服务器对请求资源采用的是基本验证机制。</p>
<p>4、实体报头<br>请求和响应消息都可以传送一个实体。一个实体由实体报头域和实体正文组成，但并不是说实体报头域和实体正文要在一起发送，可以只发送实体报头域。实体报头定义了关于实体正文（eg：有无实体正文）和请求所标识的资源的元信息。<br>常用的实体报头<br>Content-Encoding<br>Content-Encoding实体报头域被用作媒体类型的修饰符，它的值指示了已经被应用到实体正文的附加内容的编码，因而要获得Content-Type报头域中所引用的媒体类型，必须采用相应的解码机制。Content-Encoding这样用于记录文档的压缩方法，eg：Content-Encoding：gzip<br>Content-Language<br>Content-Language实体报头域描述了资源所用的自然语言。没有设置该域则认为实体内容将提供给所有的语言阅读<br>者。eg：Content-Language:da<br>Content-Length<br>Content-Length实体报头域用于指明实体正文的长度，以字节方式存储的十进制数字来表示。<br>Content-Type<br>Content-Type实体报头域用语指明发送给接收者的实体正文的媒体类型。eg：<br>Content-Type:text/html;charset=ISO-8859-1<br>Content-Type:text/html;charset=GB2312<br>Last-Modified<br>Last-Modified实体报头域用于指示资源的最后修改日期和时间。<br>Expires<br>Expires实体报头域给出响应过期的日期和时间。为了让代理服务器或浏览器在一段时间以后更新缓存中(再次访问曾访问过的页面时，直接从缓存中加载，缩短响应时间和降低服务器负载)的页面，我们可以使用Expires实体报头域指定页面过期的时间。eg：Expires：Thu，15 Sep 2006 16:23:12 GMT</p>
<p>HTTP1.1的客户端和缓存必须将其他非法的日期格式（包括0）看作已经过期。eg：为了让浏览器不要缓存页面，我们也可以利用Expires实体报头域，设置为0，jsp中程序如下：response.setDateHeader(“Expires”,”0”);</p>
<p><strong>五、HTTP协议相关技术补充</strong></p>
<p>1、基础：<br>    高层协议有：文件传输协议FTP、电子邮件传输协议SMTP、域名系统服务DNS、网络新闻传输协议NNTP和HTTP协议等<br>中介由三种：代理(Proxy)、网关(Gateway)和通道(Tunnel)，一个代理根据URI的绝对格式来接受请求，重写全部或部分消息，通过 URI的标识把已格式化过的请求发送到服务器。网关是一个接收代理，作为一些其它服务器的上层，并且如果必须的话，可以把请求翻译给下层的服务器协议。一 个通道作为不改变消息的两个连接之间的中继点。当通讯需要通过一个中介(例如：防火墙等)或者是中介不能识别消息的内容时，通道经常被使用。<br>     代理(Proxy)：一个中间程序，它可以充当一个服务器，也可以充当一个客户机，为其它客户机建立请求。请求是通过可能的翻译在内部或经过传递到其它的 服务器中。一个代理在发送请求信息之前，必须解释并且如果可能重写它。代理经常作为通过防火墙的客户机端的门户，代理还可以作为一个帮助应用来通过协议处 理没有被用户代理完成的请求。<br>网关(Gateway)：一个作为其它服务器中间媒介的服务器。与代理不同的是，网关接受请求就好象对被请求的资源来说它就是源服务器；发出请求的客户机并没有意识到它在同网关打交道。<br>　　网关经常作为通过防火墙的服务器端的门户，网关还可以作为一个协议翻译器以便存取那些存储在非HTTP系统中的资源。<br>    通道(Tunnel)：是作为两个连接中继的中介程序。一旦激活，通道便被认为不属于HTTP通讯，尽管通道可能是被一个HTTP请求初始化的。当被中继 的连接两端关闭时，通道便消失。当一个门户(Portal)必须存在或中介(Intermediary)不能解释中继的通讯时通道被经常使用。</p>
<p>2、协议分析的优势—HTTP分析器检测网络攻击<br>以模块化的方式对高层协议进行分析处理，将是未来入侵检测的方向。<br>HTTP及其代理的常用端口80、3128和8080在network部分用port标签进行了规定</p>
<p>3、HTTP协议Content Lenth限制漏洞导致拒绝服务攻击<br>使用POST方法时，可以设置ContentLenth来定义需要传送的数据长度，例如ContentLenth:999999999，在传送完成前，内 存不会释放，攻击者可以利用这个缺陷，连续向WEB服务器发送垃圾数据直至WEB服务器内存耗尽。这种攻击方法基本不会留下痕迹。<br><a href="http://www.cnpaf.net/Class/HTTP/0532918532667330.html" target="_blank" rel="noopener">http://www.cnpaf.net/Class/HTTP/0532918532667330.html</a></p>
<p>4、利用HTTP协议的特性进行拒绝服务攻击的一些构思<br>服务器端忙于处理攻击者伪造的TCP连接请求而无暇理睬客户的正常请求（毕竟客户端的正常请求比率非常之小），此时从正常客户的角度看来，服务器失去响应，这种情况我们称作：服务器端受到了SYNFlood攻击（SYN洪水攻击）。<br>而Smurf、TearDrop等是利用ICMP报文来Flood和IP碎片攻击的。本文用“正常连接”的方法来产生拒绝服务攻击。<br>19端口在早期已经有人用来做Chargen攻击了，即Chargen_Denial_of_Service，但是！他们用的方法是在两台Chargen 服务器之间产生UDP连接，让服务器处理过多信息而DOWN掉，那么，干掉一台WEB服务器的条件就必须有2个：1.有Chargen服务2.有HTTP 服务<br>方法：攻击者伪造源IP给N台Chargen发送连接请求（Connect），Chargen接收到连接后就会返回每秒72字节的字符流（实际上根据网络实际情况，这个速度更快）给服务器。</p>
<p>5、Http指纹识别技术<br>   Http指纹识别的原理大致上也是相同的：记录不同服务器对Http协议执行中的微小差别进行识别.Http指纹识别比TCP/IP堆栈指纹识别复杂许 多,理由是定制Http服务器的配置文件、增加插件或组件使得更改Http的响应信息变的很容易,这样使得识别变的困难；然而定制TCP/IP堆栈的行为 需要对核心层进行修改,所以就容易识别.<br>      要让服务器返回不同的Banner信息的设置是很简单的,象Apache这样的开放源代码的Http服务器,用户可以在源代码里修改Banner信息,然 后重起Http服务就生效了；对于没有公开源代码的Http服务器比如微软的IIS或者是Netscape,可以在存放Banner信息的Dll文件中修 改,相关的文章有讨论的,这里不再赘述,当然这样的修改的效果还是不错的.另外一种模糊Banner信息的方法是使用插件。<br>常用测试请求：<br>1：HEAD/Http/1.0发送基本的Http请求<br>2：DELETE/Http/1.0发送那些不被允许的请求,比如Delete请求<br>3：GET/Http/3.0发送一个非法版本的Http协议请求<br>4：GET/JUNK/1.0发送一个不正确规格的Http协议请求<br>Http指纹识别工具Httprint,它通过运用统计学原理,组合模糊的逻辑学技术,能很有效的确定Http服务器的类型.它可以被用来收集和分析不同Http服务器产生的签名。</p>
<p>6、其他：为了提高用户使用浏览器时的性能，现代浏览器还支持并发的访问方式，浏览一个网页时同时建立多个连接，以迅速获得一个网页上的多个图标，这样能更快速完成整个网页的传输。<br>HTTP1.1中提供了这种持续连接的方式，而下一代HTTP协议：HTTP-NG更增加了有关会话控制、丰富的内容协商等方式的支持，来提供更高效率的连接。</p>
]]></content>
      <tags>
        <tag>WEB</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构笔记3</title>
    <url>/2019/05/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B03/</url>
    <content><![CDATA[<h3 id="循环队列的顺序存储结构"><a href="#循环队列的顺序存储结构" class="headerlink" title="循环队列的顺序存储结构"></a>循环队列的顺序存储结构</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//循环队列的顺序存储结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	QElemType data[MAXSIZE];</span><br><span class="line">	<span class="keyword">int</span> front; <span class="comment">//头指针</span></span><br><span class="line">	<span class="keyword">int</span> rear;<span class="comment">//尾指针，队列非空时，指向队尾元素的下一个位置</span></span><br><span class="line">&#125;SqQueue;</span><br></pre></td></tr></table></figure>
<p>队空的条件：Q.front == Q.rear<br>队满的条件：(Q.rear+1)%MAXQSIZE == Q.front<br>求队列长度：(Q.reat-Q.front+MAXQSIZE)%MAXQSIZE<br>入队：rear++（尾指针）<br>出队：front++（头指针）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 11 <span class="comment">//初始容量</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> QElemType;<span class="comment">//定义数据类型</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//循环队列的顺序存储结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	QElemType data[MAXSIZE];</span><br><span class="line">	<span class="keyword">int</span> front; <span class="comment">//头指针</span></span><br><span class="line">	<span class="keyword">int</span> rear;<span class="comment">//尾指针，队列非空时，指向队尾元素的下一个位置</span></span><br><span class="line">&#125;SqQueue;</span><br><span class="line"> </span><br><span class="line"><span class="function">Status <span class="title">visit</span><span class="params">(QElemType item)</span></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>,item);</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//初始化空队列</span></span><br><span class="line"><span class="function">Status <span class="title">InitQueue</span><span class="params">(SqQueue *sQ)</span></span>&#123;</span><br><span class="line">	sQ-&gt;front =<span class="number">0</span>;</span><br><span class="line">	sQ-&gt;rear =<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//将队列清空</span></span><br><span class="line"><span class="function">Status <span class="title">ClearQueue</span><span class="params">(SqQueue *Q)</span></span>&#123;</span><br><span class="line">	Q-&gt;front = Q-&gt;rear =<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//判断队列是否为null</span></span><br><span class="line"><span class="function">Status <span class="title">QueueEmpty</span><span class="params">(SqQueue Q)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(Q.front == Q.rear)</span><br><span class="line">		<span class="keyword">return</span> TRUE;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//返回队列中的元素个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">QueueLength</span><span class="params">(SqQueue Q)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (Q.rear-Q.front+MAXSIZE)%MAXSIZE;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//返回队头元素</span></span><br><span class="line"><span class="function">Status <span class="title">GetHead</span><span class="params">(SqQueue Q, QElemType *e)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(Q.front == Q.rear)<span class="comment">//是否为空队列</span></span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">	*e = Q.data[Q.front];</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//在队尾插入元素</span></span><br><span class="line"><span class="function">Status <span class="title">EnQueue</span><span class="params">(SqQueue *Q, QElemType e)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>((Q-&gt;rear+<span class="number">1</span>)%MAXSIZE == Q-&gt;front)<span class="comment">//队列已满</span></span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line"> </span><br><span class="line">	Q-&gt;data[Q-&gt;rear] =e;<span class="comment">//插入队尾</span></span><br><span class="line">	Q-&gt;rear = (Q-&gt;rear +<span class="number">1</span>)%MAXSIZE;<span class="comment">//尾部指针后移，如果到最后则转到头部</span></span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//元素出队</span></span><br><span class="line"><span class="function">Status <span class="title">DeQueue</span><span class="params">(SqQueue *Q, QElemType *e)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(Q-&gt;front == Q-&gt;rear)<span class="comment">//队列空</span></span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">	*e = Q-&gt;data[Q-&gt;front];<span class="comment">//返回队头元素</span></span><br><span class="line">	Q-&gt;front = (Q-&gt;front+<span class="number">1</span>)%MAXSIZE;<span class="comment">//队头指针后移，如到最后转到头部</span></span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//遍历队列元素</span></span><br><span class="line"><span class="function">Status <span class="title">QueueTraverse</span><span class="params">(SqQueue Q)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = Q.front;</span><br><span class="line">	<span class="keyword">while</span>((i+Q.front) != Q.rear)&#123;</span><br><span class="line">		visit(Q.data[i]);</span><br><span class="line">		i=(i+<span class="number">1</span>)%MAXSIZE;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">	Status j;</span><br><span class="line">	<span class="keyword">int</span> i=<span class="number">0</span>,l;</span><br><span class="line">	QElemType d;</span><br><span class="line">	SqQueue Q;</span><br><span class="line">	InitQueue(&amp;Q);</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//入队１０个元素</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt; MAXSIZE<span class="number">-1</span>; i++)&#123;</span><br><span class="line">		EnQueue(&amp;Q,i);</span><br><span class="line">	&#125;</span><br><span class="line">	QueueTraverse(Q);</span><br><span class="line"> </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"依次出队:"</span>);</span><br><span class="line">	<span class="keyword">for</span>(l=<span class="number">1</span>;l&lt;=MAXSIZE;l++)</span><br><span class="line">	&#123;</span><br><span class="line">		DeQueue(&amp;Q,&amp;d);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"d= %d,"</span>,d);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构笔记2</title>
    <url>/2019/05/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B02/</url>
    <content><![CDATA[<h3 id="栈的顺序存储"><a href="#栈的顺序存储" class="headerlink" title="栈的顺序存储"></a>栈的顺序存储</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    Project: sequence_stack (数据结构-顺序栈)</span></span><br><span class="line"><span class="comment">	InitStack(SqStack &amp;s) 参数：顺序栈s 功能：初始化  时间复杂度O(1)</span></span><br><span class="line"><span class="comment">	Push(SqStack &amp;s,SElemType e) 参数：顺序栈s,元素e 功能：将e入栈 时间复杂度:O(1)</span></span><br><span class="line"><span class="comment">	Pop(SqStack &amp;s,SElemType &amp;e) 参数：顺序栈s,元素e 功能：出栈,e接收出栈元素值 时间复杂度O(1)</span></span><br><span class="line"><span class="comment">	GetTop(SqStack s,SElemType &amp;e) 参数：顺序栈s,元素e 功能：得到栈顶元素 时间复杂度O(1)</span></span><br><span class="line"><span class="comment">	注意：严蔚敏版没有判断栈空函数，在入栈、出栈函数里面判断栈是否空，与王道的不同 尤其是top指针在base之上(有元素时)另外，严蔚敏版 59页取栈顶有误</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Status int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SElemType int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 100</span></span><br><span class="line"><span class="comment">//栈数据结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Stack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	SElemType *base;<span class="comment">//栈底指针 不变</span></span><br><span class="line">	SElemType *top;<span class="comment">//栈顶指针 一直在栈顶元素上一个位置</span></span><br><span class="line">	<span class="keyword">int</span> stacksize;<span class="comment">//栈可用的最大容量</span></span><br><span class="line">&#125;SqStack;</span><br><span class="line"><span class="comment">//**************************************基本操作函数************************************//</span></span><br><span class="line"><span class="comment">//初始化函数</span></span><br><span class="line"><span class="function">Status <span class="title">InitStack</span><span class="params">(SqStack &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	s.base=<span class="keyword">new</span> SElemType[MaxSize];<span class="comment">//动态分配最大容量</span></span><br><span class="line">	<span class="keyword">if</span>(!s.base)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"分配失败\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	s.top=s.base;<span class="comment">//栈顶指针与栈底相同 王道上top起初在base下面，感觉很别扭，top应该高于或等于base</span></span><br><span class="line">	s.stacksize=MaxSize;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//入栈</span></span><br><span class="line"><span class="function">Status <span class="title">Push</span><span class="params">(SqStack &amp;s,SElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(s.top-s.base==s.stacksize) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//栈满</span></span><br><span class="line">	*(s.top++)=e;<span class="comment">//先入栈，栈顶指针再上移 注意与王道上的不同，具体问题具体分析</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;	</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//出栈 用e返回值,注意e是应用类型</span></span><br><span class="line"><span class="function">Status <span class="title">Pop</span><span class="params">(SqStack &amp;s,SElemType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(s.top==s.base) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//栈空</span></span><br><span class="line">	e=*--s.top;<span class="comment">//先减减 指向栈顶元素，再给e</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;	</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//得到栈顶元素，不修改指针</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">GetTop</span><span class="params">(SqStack s,SElemType &amp;e)</span> <span class="comment">//严蔚敏版59页有问题，应该用e去获得，函数返回bool类型去判断</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(s.top==s.base) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//栈空			</span></span><br><span class="line">	<span class="keyword">else</span> e=*--s.top;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//********************************功能实现函数**************************************//</span></span><br><span class="line"><span class="comment">//菜单</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">menu</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"********1.入栈      2.出栈*********\n"</span>);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"********3.取栈顶    4.退出*********\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//入栈功能函数 调用Push函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PushToStack</span><span class="params">(SqStack &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;SElemType e;<span class="keyword">int</span> flag;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"请输入入栈元素个数(&gt;=1)：\n"</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">	 <span class="built_in">printf</span>(<span class="string">"请输入第%d个元素的值:"</span>,i+<span class="number">1</span>);</span><br><span class="line">	 <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;e);</span><br><span class="line">	 flag=Push(s,e);</span><br><span class="line">	 <span class="keyword">if</span>(flag)<span class="built_in">printf</span>(<span class="string">"%d已入栈\n"</span>,e);</span><br><span class="line">	 <span class="keyword">else</span> &#123;<span class="built_in">printf</span>(<span class="string">"栈已满！！！\n"</span>);<span class="keyword">break</span>;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//出栈功能函数 调用Pop函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PopFromStack</span><span class="params">(SqStack &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;SElemType e;<span class="keyword">int</span> flag;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"请输入出栈元素个数(&gt;=1)：\n"</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">	 flag=Pop(s,e);</span><br><span class="line">	 <span class="keyword">if</span>(flag)<span class="built_in">printf</span>(<span class="string">"%d已出栈\n"</span>,e);</span><br><span class="line">	 <span class="keyword">else</span> &#123;<span class="built_in">printf</span>(<span class="string">"栈已空！！！\n"</span>);<span class="keyword">break</span>;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//取栈顶功能函数 调用GetTop</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetTopOfStack</span><span class="params">(SqStack &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	SElemType e;<span class="keyword">bool</span> flag; </span><br><span class="line">	flag=GetTop(s,e);</span><br><span class="line">	<span class="keyword">if</span>(flag)<span class="built_in">printf</span>(<span class="string">"栈顶元素为:%d\n"</span>,e);</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"栈已空！！！\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//主函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> SqStack s;<span class="keyword">int</span> choice;</span><br><span class="line"> InitStack(s);</span><br><span class="line"> <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line"> &#123;</span><br><span class="line">  menu();</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"请输入菜单序号：\n"</span>);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;choice);</span><br><span class="line">  <span class="keyword">if</span>(choice==<span class="number">4</span>) <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">switch</span>(choice)</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:PushToStack(s);<span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>:PopFromStack(s);<span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">3</span>:GetTopOfStack(s);<span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:<span class="built_in">printf</span>(<span class="string">"输入错误！！！\n"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构笔记1</title>
    <url>/2019/05/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B01/</url>
    <content><![CDATA[<h3 id="线性表的链式存储"><a href="#线性表的链式存储" class="headerlink" title="线性表的链式存储"></a>线性表的链式存储</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    Project: single linkeed list (数据结构 单链表)</span></span><br><span class="line"><span class="comment">	InitList(LinkList &amp;L) 参数：单链表L 功能：初始化 时间复杂度 O(1)</span></span><br><span class="line"><span class="comment">	ListLength(LinkList L) 参数：单链表L 功能：获得单链表长度 时间复杂度O(n) </span></span><br><span class="line"><span class="comment">	ListInsert(LinkList &amp;L,int i,ElemType e) 参数：单链表L,位置i，元素e 功能：位置i后插 时间复杂度O(n)[加入了查找]若已知指针p指向的后插 O(1)</span></span><br><span class="line"><span class="comment">	ListDelete(LinkList &amp;L,int i) 参数：单链表L，位置i 功能：删除位置i元素 时间复杂度O(n)[加入了查找] 若已知p指针指向的删除 最好是O(1),因为可以与后继结点交换数据域，然后删除后继结点。最坏是O(n),即从头查找p之前的结点,然后删除p所指结点</span></span><br><span class="line"><span class="comment">	LocateElem(LinkList L,ElemType e) 参数：单链表L，元素e 功能：查找第一个等于e的元素，返回指针 时间复杂度O(n) </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Status int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ElemType int</span></span><br><span class="line"><span class="comment">//单链表结点数据结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	ElemType data;<span class="comment">//数据域</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span><span class="comment">//指针域</span></span><br><span class="line">&#125;LNode,*LinkList;</span><br><span class="line"><span class="comment">//**************************基本操作函数***************************//</span></span><br><span class="line"><span class="comment">//初始化函数</span></span><br><span class="line"><span class="function">Status <span class="title">InitList</span><span class="params">(LinkList &amp;L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> L = <span class="keyword">new</span> LNode;<span class="comment">//生成头结点 这样删除等操作就不必分第一个结点和其他了</span></span><br><span class="line"> L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取单链表长度 头结点无数据，不算</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ListLength</span><span class="params">(LinkList L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	LinkList p=L;<span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(p)</span><br><span class="line">	&#123;</span><br><span class="line">	 sum++;</span><br><span class="line">	 p=p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sum<span class="number">-1</span>;<span class="comment">//去除头结点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//插入函数--后插法 插入到第i(1&lt;=i&lt;=length+1)个位置 即i-1之后 不必区分i的位置</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ListInsert</span><span class="params">(LinkList &amp;L,<span class="keyword">int</span> i,ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	LNode* s;LinkList p=L;<span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(p&amp;&amp;(j&lt;i<span class="number">-1</span>))<span class="comment">//j指到i-1位置</span></span><br><span class="line">	&#123;</span><br><span class="line">	 p=p-&gt;next;</span><br><span class="line">	 ++j;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(!p||j&gt;i<span class="number">-1</span>)<span class="comment">//i&lt;1或者i&gt;ListLength(L)+1时,插入位置无效 不调用ListLength,提高效率</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"插入位置无效！！！\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	s=<span class="keyword">new</span> LNode;</span><br><span class="line">	s-&gt;data=e;</span><br><span class="line">	s-&gt;next=p-&gt;next;</span><br><span class="line">	p-&gt;next=s;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//删除函数 删除位置i的结点 即删除i-1之后的结点</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ListDelete</span><span class="params">(LinkList &amp;L,<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> 	LNode* s;LinkList p=L;<span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">	LinkList q;</span><br><span class="line">	<span class="keyword">while</span>(p&amp;&amp;(j&lt;i<span class="number">-1</span>))<span class="comment">//j指到i-1位置</span></span><br><span class="line">	&#123;</span><br><span class="line">	 p=p-&gt;next;</span><br><span class="line">	 ++j;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(!(p-&gt;next)||j&gt;i<span class="number">-1</span>)<span class="comment">//i&lt;1或者i&gt;ListLength(L)时,删除位置无效</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"删除位置无效！！！\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	q=p-&gt;next;</span><br><span class="line">	p-&gt;next=q-&gt;next;</span><br><span class="line">	<span class="built_in">free</span>(q);<span class="comment">//释放空间</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查找函数 按值查找 查找第一个等于e的结点 成功返回该结点指针，否则返回NULL</span></span><br><span class="line"><span class="function">LNode *<span class="title">LocateElem</span><span class="params">(LinkList L,ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	LNode *p=L;</span><br><span class="line">	<span class="keyword">while</span>(p&amp;&amp;(p-&gt;data!=e))</span><br><span class="line">	&#123;</span><br><span class="line">		p=p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//**************************功能实现函数**************************//</span></span><br><span class="line"><span class="comment">//遍历输出函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintList</span><span class="params">(LinkList L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	LinkList p=L-&gt;next;<span class="comment">//跳过头结点</span></span><br><span class="line">	<span class="keyword">if</span>(ListLength(L))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"当前单链表所有元素:"</span>);</span><br><span class="line">		<span class="keyword">while</span>(p)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d "</span>,p-&gt;data);</span><br><span class="line">			p=p-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"当前单链表已空！\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//插入功能函数 调用ListInsert后插</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(LinkList &amp;L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> place;ElemType e;<span class="keyword">bool</span> flag;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"请输入要插入的位置(从1开始)及元素:\n"</span>);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;place,&amp;e);</span><br><span class="line">  flag=ListInsert(L,place,e);</span><br><span class="line">  <span class="keyword">if</span>(flag) </span><br><span class="line">  &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"插入成功！！！\n"</span>);</span><br><span class="line">	PrintList(L);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//删除功能函数 调用ListDelete删除</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Delete</span><span class="params">(LinkList L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> place;<span class="keyword">bool</span> flag;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"请输入要删除的位置(从1开始):\n"</span>);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;place);</span><br><span class="line">  flag=ListDelete(L,place);</span><br><span class="line">  <span class="keyword">if</span>(flag) </span><br><span class="line">  &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"删除成功！！！\n"</span>);</span><br><span class="line">	PrintList(L);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查找功能函数 调用LocateElem查找</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Search</span><span class="params">(LinkList L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ElemType e;LNode *q;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"请输入要查找的值:\n"</span>);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;e);</span><br><span class="line">  q=LocateElem(L,e);</span><br><span class="line">  <span class="keyword">if</span>(q) </span><br><span class="line">  &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"找到该元素！\n"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"未找到该元素！\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//菜单</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">menu</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"********1.后插    2.删除*********\n"</span>);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"********3.查找    4.输出*********\n"</span>);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"********5.退出          *********\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//主函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> LinkList L;<span class="keyword">int</span> choice;</span><br><span class="line"> InitList(L);</span><br><span class="line"> <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line"> &#123;</span><br><span class="line">  menu();</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"请输入菜单序号：\n"</span>);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;choice);</span><br><span class="line">  <span class="keyword">if</span>(choice==<span class="number">5</span>) <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">switch</span>(choice)</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:Insert(L);<span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>:Delete(L);<span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">3</span>:Search(L);<span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">4</span>:PrintList(L);<span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:<span class="built_in">printf</span>(<span class="string">"输入错误！！！\n"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统笔记整理</title>
    <url>/2019/05/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B04/</url>
    <content><![CDATA[<p>0x1 不管系统中是否有线程，进程都是拥有资源的独立单位<br>0x2 管程技术是用来解决进程同步的<br>0x4 对进程的管理和控制使用的是原语<br>0x5 并发执行的特征：间断性、失去封闭性、不可再现性<br>0x6 在单处理机系统实现并发后，各进程在某一时间段并行运行，CPU与外部设备之间并行工作<br>0x7 文件系统的主要目的是实现对文件的按名存取<br>0x8 通道控制设备控制器，设备在设备控制器控制下工作<br>0x9 操作系统的基本类型是实时系统、分时系统和批处理系统<br>0xA PMT 页表（页面变换表） DCT设备控制表<br>0xB 虚拟存储器的叙述正确的是：要求程序运行前不必全部装入内存且在运行过程中不必一直驻留在内存<br>0xC 虚拟存储器采用了以“时间”换“空间”的技术<br>0xD 在可变分区存储管理中，最优适应分配算法要求对空闲区表项按尺寸从小到大进行排列<br>0xE 并发是指若干个事件在同一时间段内发生， 并行是指若干个事件在同一时刻发生。<br>0xF 进程的基本特征有动态性、并发性 、独立性、异步性及结构特征</p>
<h3 id="Ch1"><a href="#Ch1" class="headerlink" title="Ch1"></a>Ch1</h3><p><strong>1、从用户、资源管理、资源抽象三个角度看，操作系统的作用分别是什么。</strong><br>OS作为用户与计算机硬件系统之间的接口；<br>OS作为计算机系统资源的管理者；<br>OS实现了对计算机资源的抽象<br><strong>2、操作系统是什么软件？位于哪一层之上？</strong><br>OS是配置在计算机硬件上的第一层软件，是对硬件系统的首次扩充。OS是现代计算机系统中最基本最重要的系统软件。<br><strong>3、从资源管理的角度看，操作系统的4大主要功能。</strong><br>处理机管理，存储器管理，设备管理，文件管理<br><strong>4、理解操作系统的主要特性：并发、共享、虚拟和异步。其中操作系统最基本的两个特征是什么？</strong><br>并发：是指两个或多个事件在同一时间间隔内发生。<br>共享：是指系统中的资源（硬件资源和信息资源）可以被多个并发执行的程序共同使用，而不是被其中一个独占。资源共享有两种方式：互斥访问和同时访问。<br>异步：在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底。而是走走停停，以不可预知的速度向前推进，这就是进程的异步性。<br>虚拟：虚拟性是一种管理技术，把物理上的一个实体变成逻辑上的多个对应物，或把物理上的多个实体变成逻辑上的一个对应物的技术。<br>并发和共享是操作系统最基本的两个特征<br><strong>5、理解操作系统的基本类型：批处理操作系统（了解优缺点）、分时操作系统（了解2个关键问题，了解特征）和实时操作系统。</strong><br>批处理操作系统的优点：资源利用率高，系统吞吐量大。<br>批处理操作系统的缺点：平均周转时间长，无交互能力。分时操作系统的2个关键问题：及时接收，及时处理<br>分时操作系统的特征：多路性、独立性、及时性、交互性<br>实时操作系统：实时操作系统的特征比分时多一个可靠性。<br><strong>6、多道程序设计是指什么？</strong><br>多道程序设计是指内存中存放多个进程来执行调度任务，内存中多个进程共享计算机资源<br><strong>7、操作系统作为用户与计算机硬件系之间的接口，用户可通过三种方式使用计算机，这些方式是指什么。</strong><br>命令方式、系统调用方式、图标-窗口方式</p>
<h3 id="Ch2"><a href="#Ch2" class="headerlink" title="Ch2"></a>Ch2</h3><h3 id="1、理解进程的定义，-进程的3个组成部分。"><a href="#1、理解进程的定义，-进程的3个组成部分。" class="headerlink" title="1、理解进程的定义， 进程的3个组成部分。"></a><strong>1、理解进程的定义， 进程的3个组成部分。</strong></h3><p><img src="http://www.liuchuo.net/wp-content/uploads/2016/06/Snip20160628_108.png" alt="Snip20160628_108"><br>进程的定义：进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。<br>进程的组成部分：程序段、相关的数据段和PCB控制块<br><strong>2、理解进程的三种基本状态转换及用图表示。</strong><br>就绪   阻塞  执行<br><strong>3、进程控制块PCB中的4个方面的信息，进程与PCB之间的对应关系。（P40-41选择题、填空题、简答题）</strong><br>进程控制块的组成：进程标识符，处理机状态，进程调度信息，进程控制信息。<br>进程与PCB是一一对应的关系。当系统建立一个新进程时，就为它建立一个PCB。进程结束时又收回它的PCB，进程也随之消亡。系统是通过PCB感知进程存在的。PCB是进程存在于系统中的唯一标志。<br><strong>4、进程控制一般是由什么来实现的？什么是原语?</strong><br>进程控制一般由OS内核中的原语来实现。<br>原语就是由若干条指令组成的，用户完成一定功能的一个过程。它是一个不可分割的基本单位。原语在执行的过程中不可以被中断。<br><strong>5、在多道程序设计系统中，并发进程之间可能存在的2种制约关系：进程互斥和进程同步（P48填空题、选择题）</strong><br>间接相互制约关系：因为对临界资源共享的互斥访问而引起的<br>直接相互制约关系：为了完成某任务而建立的两个或者多个进程之间的制约关系<br><strong>6、线程与进程的区别。（选择题）</strong><br>进程作为调度和分派的基本单位，线程是能够独立运行的基本单位<br>线程使OS具有更好地并发性<br>进程可以拥有资源，并作为系统中拥有资源的一个基本单位。线程本身并不拥有系统资源，而是仅有一点必不可少的、能保证独立运行的资源。<br>不同线程之间的独立性比不同进程之间的独立性低的多。<br>线程创建或撤销的开销小于进程的创建和撤销的开销。<br>在多处理系统中，多线程进程可以将一个进程中的多个线程分配到多个处理机上，并行执行。<br><strong>7、并发进程的特征（与顺序程序设计相比）：（选择题）</strong><br>间断性、失去封闭性、不可再现性<br><strong>8、临界区（P50）、临界资源的定义。</strong><br>临界区：访问临界资源的那段代码。<br>临界资源：一段时间内只允许一个进程访问的资源。（每个进程应采取互斥访问的方式，实现对这种资源的共享）<br><strong>9、同步机制应遵循基本准则（或临界区调度原则）。</strong><br>空闲让进、忙则等待、有限等待、让权等待<br><img src="http://www.liuchuo.net/wp-content/uploads/2016/06/Snip20160628_109.png" alt="Snip20160628_109"><br><strong>10、信号量：（填空题、选择题）</strong><br>一种是用于实现进程互斥的信号量，初值一般为1；当为0时表示什么含义。<br>= 1表示只允许一个进程访问临界资源<br>= 0 表示一个进程已进入临界区<br>另一种是用于解决进程同步的信号量，初值表示资源的数量。 有两种题型：<br>【题型1】有3个进程共享同一程序段，而每次最多允许两个进程进入该程序段，若用P、V操作作同步机制，则记录型信号量S的取值范围为(-1 0 1 2)。<br>【题型2】若记录型信号量S的初值为2，当前值为-1，则表示有(  1)等待进程。<br>信号量为负时，表示资源分配完毕，信号量的绝对值表示已阻塞进程的数目<br><strong>11、利用信号量实现前驱关系（P57图2-14类似，程序填空题）</strong><br>进程向后继进程分配信号量，后继进程等待接收前驱进程的信号量<br><img src="http://www.liuchuo.net/wp-content/uploads/2016/06/Snip20160628_110.png" alt="Snip20160628_110"><br><strong>12、了解管程的作用，即用来做什么的（选择题）</strong><br>管程的作用：确保每次仅有一个进程进入管程，执行这组过程，使用共享资源，达到对共享资源所有访问的统一管理。</p>
<h3 id="Ch3"><a href="#Ch3" class="headerlink" title="Ch3"></a>Ch3</h3><p><strong>1、了解处理器调度的3种调度是什么及其调度对象分别是什么。了解进程调度的任务。（填空题、选择题）</strong><br>3种调度——高级调度：长程调度或作业调度<br>中级调度：进程调度或短程调度<br>低级调度：内存调度<br>进程调度的任务——保存处理机的现场信息<br>按某种算法选取进程<br>把处理器分配给进程<br><strong>2、周转时间的计算（采用先来先服务调度算法和最短作业优先调度算法时的平均周转时间）</strong><br><strong>题型：设有三道作业，它们的提交时间和运行时间如下表：</strong><br><img src="http://www.liuchuo.net/wp-content/uploads/2016/06/Snip20160628_102.png" alt="Snip20160628_102"></p>
<p>求：试给出下面两种调度算法下，作业的执行顺序、平均周转时间和平均带权周转时间。<br>(1)先来先服务FCFS调度算法<br><img src="http://www.liuchuo.net/wp-content/uploads/2016/06/Snip20160628_103.png" alt="Snip20160628_103"><br>作业的执行顺序: 1  2   3<br>平均周转时间：T = (2 + 2.9 +3) / 3 = 2.63<br>平均带权周转时间：T = (1 + 2.9 + 12) / 3 = 5.3<br>(2)短作业优先SJF调度算法<br><img src="http://www.liuchuo.net/wp-content/uploads/2016/06/Snip20160628_104.png" alt="Snip20160628_104"><br>作业的执行顺序：1 3 2<br>平均周转时间：T = (2 + 2.25 + 3.15) / 3 = 2.46<br>平均带权周转时间：T = (1 + 9 + 3.15) / 3 = 4.38<br><strong>3、了解基本的作业调度和低级调度算法：先来先服务算法FCFS、最短作业优先算法SJF、响应比最高者优先算法HRRF和优先级调度算法。（填空题、选择题）</strong><br>高响应比优先算法：优先权 = (等待时间 + 要求服务时间) / 要求服务时间<br>高响应比优先算法既考虑了作业的等待时间，又考虑作业运行时间<br>优先级调度算法（既可用于作业调度又可用作进程调度）：从后备队列中选择若干个优先级最高的作业装入内存。<strong>4、死锁的定义及其产生死锁的原因和必要条件（简答题、选择题）</strong><br>死锁：一组进程中的每一个进程都在等待仅由该组进程中的其它进程才能引发的事件，那么该组进程是死锁的<br><strong>产生死锁的四个必要条件是：互斥条件、请求和保持条件、不可抢占条件、循环等待条件。</strong><br>互斥条件：进程要求对所分配的资源进行排它性控制，即在一段时间内某资源仅为一进程所占用。<br>请求和保持条件：当进程因请求资源而阻塞时，对已获得的资源保持不放。<br>不剥夺条件：进程已获得的资源在未使用完之前，不能剥夺，只能在使用完时由自己释放。<br>循环等待条件：在发生死锁时，必然存在一个进程–资源的环形链。<br>0x1 银行家算法（参加书上例题P113，综合题）<br>0x2 求系统中各种资源的总数<br>已经分配出去的资源 + 系统当前可用的资源 = 系统中各种资源的总数<br>0x3 某时刻各进程对各资源的需求数目即Need矩阵。<br>Need[i, j] = Max[i, j] – Allocation[i, j]<br>0x4 在某时刻系统是否是安全的（找安全序列）<br>安全性算法中，work表示系统可提供给进程继续运行所需的各类资源数目，执行安全算法开始时，work = available<br>步骤：利用安全性算法对xx时刻的资源分配情况进行分析<br>建立表格：work（第一个已知，其他都是上一行的work+allocation）、need（已知）、allocation（已知）、work+allocation、finish（true or false）<br>在xx时刻存在着一个安全序列{xx，xx，xx，xx}，故系统是安全的<br><strong>5 如果此时某进程发出资源请求向量Request( )，是否能实施资源分配？为什么？</strong><br>0x1 request1 &lt; need1<br>0x2 request1 &lt; available<br>0x3 系统先假定可以为p1分配资源，并修改available allocation1 和 need1向量<br>0x4 再利用安全性算法检查此时系统是否安全<br>0x5 由所进行的安全性检查得知，可以找到一个安全序列{x,x,x,x}。因此系统是安全的</p>
<h3 id="Ch4"><a href="#Ch4" class="headerlink" title="Ch4"></a>Ch4</h3><p><strong>1、存储管理是对内存的什么区域进行管理？</strong><br>用户区<br><strong>2、了解逻辑地址与物理地址的概念，重定位的概念（填空题)</strong><br>逻辑地址（Logical Address） 是指由程序产生的与段相关的偏移地址部分<br>物理地址（Physical Address） 是指出现在CPU外部地址总线上的寻址物理内存的地址信号，是地址变换的最终结果。<br>重定位就是把程序的逻辑地址空间变换成内存中的实际物理地址空间的过程，也就是说在装入时对目标程序中指令和数据的修改过程。<br><strong>3、理解常用动态（可变）分区分配算法：</strong><br>0x1 首次（最先）适应算法、<br>0x2 最佳适应算法、<br>0x3 最坏适应算法。它们的空闲区表项是按什么规则排列（空闲链表）。（填空题、选择题）<br>首次适应算法即每次都从头遍历找到第一个符合的分区，最佳适应的是每次都找到那个和它大小相差的最小的那个分区，最坏适应算法，是每次都找最大的那个分区<br><strong>4、动态（可变）分区分配方案中，某一作业完成后，系统收回其主存空间，了解回收空闲区的4种情况的回收规则，空闲分区表的变化。（填空题、选择题）</strong><br><strong>5、分页存储管理的原理（填空题，综合题)</strong><br>题型：分页式存储管理系统，内存的大小为64KB，被分成16块，块号为0、1、2、…、15。设某进程有3页，其页号为0、1、2，被分别装入内存的2、4、7，问：<br>0x1 内存地址应使用多少位来表示？进程每一页的长度为多少B？逻辑地址中的页内地址应该用多少位？  逻辑地址应该用多少位？<br>0x2 写出该进程每一页在内存的起始地址。<br>0x3 逻辑地址5276、或者0A12H（十六进制）对应的物理地址是多少？<br>内存地址：64k = 2^6 <em> 2^10 = 2^16用16位表示<br>进程每一页的长度为64KB / 16 = 4KB；<br>逻辑地址中的页内地址应该用12位表示；<br>逻辑地址应该用14位表示；【因为页号用2位表示，2+12=14位】<br>0页2 </em> 4KB， 1页4 <em> 4KB， 2页7 </em> 4KB<br>页号为 5276 / 4k = 5276 / 4096 = 1 , 页内地址为 5276 % 4096 = 1180 物理地址 = 4<em> 4KB + 1180 ；<br>0A12h的十进制为2578 。<br>页号： 2578 / 4k = 2578 / 4096 = 0, 页内地址为 2578 % 4096 = 2578 ，物理地址为：2 </em> 4KB + 2578<br><strong>6、分段存储管理系统中物理地址的计算（填空题，综合题)</strong><br>题型：某段表的内容如下：<br>段号       段首址        段长度<br>0          120K           40K<br>1          760K           30K<br>2          480K           20K<br>3          370K           20K<br>一逻辑地址为（2,154B），它对应的物理地址为多少？<br>可能越界：一种是段长和另一种是段号的越界<br>480K+154B</p>
<h3 id="Ch5"><a href="#Ch5" class="headerlink" title="Ch5"></a>Ch5</h3><p><strong>1、虚拟存储器的定义，基于什么原理提出的（P155填空题、简答题）</strong><br>虚拟存储器是指具有请求调入功能和置换功能，能从逻辑上对内存容量加以扩充的一种存储器系统。<br>虚拟存储器是基于离散分配的原理提出的。<br><strong>2、什么是程序执行时的时间局限性和空间局限性？P154（简答题）</strong><br>时间局限性：如果程序中的指令被执行，则不久以后该指令可能再次执行；如果某数据被访问过，则不久以后该数据可能再次被访问。<br>空间局限性：一旦程序访问了某个存储单元，在不久之后，其附近的存储空间也将被访问，即程序在一段时间内所访问的地址可能集中在一定的范围之内，其典型情况便是程序的顺序执行。<br><strong>3、常见的页面置换算法：最佳页面置换算法OPT、先进先出页面置换算法FIFO、最近最少使用页面置换算法LRU。（填空题、选择题、综合题）</strong><br>题型：假定某请求页式虚拟系统中，某进程的页面访问为：0,0,3,1,1,4,0,5,6,6,2,4,6,7,7,0,0,6,7,2，进程实际页面数为3，则按先进先出FIFO置换算法和最近最久未使用LRU置换算法，求缺页中断次数和缺页率。<br>(1)FIFO<br><img src="http://www.liuchuo.net/wp-content/uploads/2016/06/Snip20160628_116.png" alt="Snip20160628_116"><br>缺页中断次数：13；缺页率：产生中断的次数 / 总访问次数 = 13 / 20 =  0.65</p>
<p>(1)LRU<br><img src="http://www.liuchuo.net/wp-content/uploads/2016/06/Snip20160628_117.png" alt="Snip20160628_117"><br>缺页中断次数：12；缺页率：12 / 20 = 0.6<br>(3)OPT<br>选择在最长（未来）时间内不再被访问的页面。<br>缺页次数和缺页率计算如上</p>
<h3 id="Ch6"><a href="#Ch6" class="headerlink" title="Ch6"></a>Ch6</h3><p><strong>1、有哪些I/O控制方式，工作方式（填空题、简答题、选择题）</strong><br>答：采用轮询的可编程I/O方式；采用中断的可编程I/O方式；直接存储器访问方式；I/O通道方式<br><strong>2、系统的设备分配程序进行独占设备分配的步骤是什么？（P203填空题）</strong><br>答： 分配设备、分配控制器、分配通道<br><strong>3、通道又称I/O处理机，用于完成什么之间的信息传输。（填空题、选择题）</strong><br>答：CPU和设备控制器<br><strong>4、通道、设备控制器和设备（三者联接位置，即控制关系）。（填空题、选择题）</strong><br>通道控制设备控制器，设备在设备控制器控制下工作<br><strong>5、 通道的定义、三种通道类型及其特点（连接的设备类型）（选择题）。</strong><br>通道的定义：一个独立于CPU的专门的I/O控制的处理机，控制设备与内存直接进行信息交换。<br>通道类型有：字节多路通道，按字节多路交叉方式工作的通道；<br>数组选择通道，可以连接多台高速设备，通道的利用率很低；<br>数组多路通道，将数组选择通道传输速率高和字节多路通道分时并行操作的优点结合。<br><strong>6、了解常用的缓冲技术的作用（选择题）及类型。</strong><br>缓冲技术的作用：缓和CPU和I/O设备间速度不匹配的矛盾；<br>减少对CPU的中断频率，放宽对CPU中断响应时间的限制；<br>解决数据粒度不匹配的问题；<br>提高CPU和I/O设备之间的并行性。<br>缓冲技术的类型有：单缓冲、双缓冲、环形缓冲和缓冲池。<br><strong>7、Spooling系统的作用、组成（填空题、简答题）P207</strong><br>Spooling系统技术的作用：缓和CPU与I/O设备之间速度不匹配的矛盾<br>SPO·OLing系统是对脱机I/O工作方式的模拟，SPOOLing系统是由：<br>1.磁盘中的(输入井)和(输出井),是对脱机输入输出中的磁盘进行模拟；<br>2.内存中的(输入缓冲区)和(输出缓冲区),用来缓和CPU与磁盘之间的速度的矛盾；<br>3.(输入进程)和(输出进程)所构成，是对脱机输入输出中的外围控制机进行模拟。<br>4.(井管理程序)，用于控制作业与磁盘井之间信息的交换。<br><strong>8、I/O系统管理的对象是什么？（P178）按照各层次及其功能，I/O软件的4层是什么?</strong><br>I/O系统管理的对象:I/O设备和相应的设备控制器<br>四个层次：用户层I/O软件、设备独立性软件、设备驱动程序、中断处理程序<br><strong>9、设备独立性是指什么？在有设备独立性系统中，逻辑设备表的作用是什么？（选择题）设备独立性：应用程序中的所有设备，不局限于使用某个具体的物理设备。</strong><br>逻辑设备表的作用：实现从逻辑设备名称到物理设备名称的转换。<br><strong>10、掌握当前磁盘（1）先来先服务（2）最短寻道时间优先（3）电梯算法。（综合题、填空题）</strong><br>【题型】假定一磁盘有200个柱面,编号为0—199,在完成了磁道125处的请求后,当前正在磁道143处为一个请求服务。若请求队列的先后顺序为<br>86,147,91,177,94,150,102,175,130<br>试分别采用FCFS(先来先服务)、SSTF(最短寻道时间优先)、SCAN(扫描)算法完成上述请求,写出磁头移动的顺序,并计算存取臂移动总量(单位为磁道数)。<br><img src="http://www.liuchuo.net/wp-content/uploads/2016/06/Snip20160628_118.png" alt="Snip20160628_118"></p>
<h3 id="Ch7"><a href="#Ch7" class="headerlink" title="Ch7"></a>Ch7</h3><p><strong>1、文件系统的主要目的、概念（选择题、填空题）</strong><br>文件系统的主要目的是实现对文件的按名存取<br>文件系统最基本的目标是 （按名存取），它主要是通过(目录管理)功能实现的,文件系统所追求的最重要目标是 （提高对文件的存取速度）。<br>按逻辑结构可把文件分为：记录式文件、流式文件<br><strong>2、文件目录的作用（选择题）</strong><br>作用：实现文件名到物理地址的转换。</p>
]]></content>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统笔记3</title>
    <url>/2019/04/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B03/</url>
    <content><![CDATA[<h3 id="临界资源、临界区、信号量、P-V操作"><a href="#临界资源、临界区、信号量、P-V操作" class="headerlink" title="临界资源、临界区、信号量、P,V操作"></a>临界资源、临界区、信号量、P,V操作</h3><p><strong>资源：</strong><br>Linux上有硬件资源和软件资源之分。程序会受到资源限制的影响，可能在这几方面的资源限制受到影响：1.硬件方面的物理性限制（内存）；2.系统策略的限制（允许使用的CPU时间）；3.具体实现的限制（整数的长度、文件名中所允许的最大字符数）。<br><strong>临界资源：</strong><br>临界资源是一次仅允许一个进程使用的共享资源。每次只准许一个进程进入临界区，进入后不允许其他进程进入。不论是硬件临界资源，还是软件临界资源，多个进程必须互斥地对它进行访问。<br><strong>临界区：</strong><br>临界区指的是一个访问共用资源（例如：共用设备或是共用存储器）的程序片段，而这些共用资源又无法同时被多个线程访问的特性。当有线程进入临界区段时，其他线程或是进程必须等待（例如：bounded waiting 等待法），有一些同步的机制必须在临界区段的进入点与离开点实现，以确保这些共用资源是被互斥获得使用，例如：semaphore。只能被单一线程访问的设备，例如：打印机。<br><strong>信号量：</strong><br>信号量（Semaphore）有时被称为信号灯，是解决并发问题过程中所使用的一种设施，可以用来保证两个或多个关键代码段不被并发调用。一个进程在进入一个关键代码段之前，进程（或线程）必须获取一个信号量；一旦关键代码段完成了，那么该进程（或线程）必须释放信号量。其它想进入该关键代码段的进程（或线程）必须等待直到第一个进程（或线程）释放信号量。</p>
<p>从并发机制的角度看，信号量是一种并发机制，它用于进程间传递信号的一个整数值。在信号量上只有3中操作可以进行：初始化、递减和增加，这三种都是原子操作。递减操作可以用于阻塞一个进程，增加操作可以用于解除阻塞一个进程。也成为计数信号量或一般信号量。（其它的并行机制还有很多，如二元信号量、互斥量、自旋锁、事件标志等）<br><strong>简单的理解：</strong>信号量：特殊变量，加1（v操作，释放资源），减1（p操作，获取资源），都是一个原子操作，值为0，减1阻塞。信号量用来同步进程。同步：只有一个程序在执行。<br>五、原子操作：它在执行过程中不能被打断。<br><strong>P，V操作：</strong><br>实际上p操作就是-1（获取资源），v操作就是+1（释放资源）。<br>我的理解也就是信号量用来解决互斥问题的一种方法。设信号量为s,设有n个进程，所有的进程都需要访问共享资源。每个进程中进入临界区前执行semWait(s),如果s的值为负，则进程被阻塞，s的绝对值就是被阻塞进程的数量；如果值为1，则s被减为0，进程立即进入临界区；由于s不再为正，因而其他任何程序都不能进入临界区。信号量一般初始化为1，这样第一个执行semWait的进程可以立即进入临界区，并把s的值置为0。接着任何试图进入临界区的其他（一个）进程，都将发现第一个进程忙，因此被阻塞，把s的值置为-1。可以有任意数目的进程试图进入，每个不成功的尝试都会使s的值减1，当最初进入临界区的进程离开时，s的值增1，一个被阻塞的进程（如果有的话）被移出阻塞队列，置为就绪状态（这里的s的值增1和一个阻塞进程被移出置为就绪状态是一步完成的）。这样，当操作系统下一次调度时，它可以进入临界区，并把信号量的值置为0。<br>PV操作与信号量的处理相关，P表示通过的意思，V表示释放的意思。p操作和v操作是不可中断的程序段，称为原语。如果将信号量看作共享变量，则pv操作为其临界区，多个进程不能同时执行，一般用硬件方法保证。一个信号量只能置一次初值，以后只能对之进行p操作或v操作。<br><strong>使用PV操作实现进程互斥时应该注意的是：</strong><br>0x1 每个程序中用户实现互斥的P、V操作必须成对出现，先做P操作，进临界区，后做V操作，出临界区。若有多个分支，要认真检查其成对性。<br>0x2 P、V操作应分别紧靠临界区的头尾部，临界区的代码应尽可能短，不能有死循环。<br>0x3  互斥信号量的初值一般为1。<br><strong>一些其它的知识</strong><br>0x1 二值信号量   0   1<br>0x2 计数信号量   可能会&gt;1<br>0x3 semget 创建信号量<br>0x4 semop  修改信号量的值   实现p v操作<br>0x5 semctl   初始化信号量  删除<br>0x6 信号量的使用<br>1）创建信号量，初始化值为1<br>2）提供P V操作<br>3）使用临界资源之前执行P操作，用完执行V操作<br>4）销毁信号量<br>0x7 ipcs命令<br>ipcs –q  查看消息队列      ipcs  -s<br>ipcrm  -s  +信号量id：手动清楚信号量<br>ipcs  -m  显示共享内存</p>
]]></content>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统笔记2</title>
    <url>/2019/04/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B02/</url>
    <content><![CDATA[<h3 id="程序、进程和线程的区别"><a href="#程序、进程和线程的区别" class="headerlink" title="程序、进程和线程的区别"></a>程序、进程和线程的区别</h3><p>程序是一组指令及参数的集合，指令按照既定的逻辑控制计算机运行。进程则是运行着的程序，是操作系统执行的基本单位。线程则是为了节省资源而可以在同一个进程中共享资源的一个执行单位。</p>
<h3 id="程序和进程的区别"><a href="#程序和进程的区别" class="headerlink" title="程序和进程的区别"></a>程序和进程的区别</h3><p>C、C++、Java等语言编写的源程序经相应的编译器编译成可执行文件后，提交给计算机处理器运行。应用程序的运行状态称为进程。进程与应用程序的区别在于应用程序作为一个静态文件存储在计算机系统的硬盘等存储空间中，而进程则是处于动态条件下由操作系统维护的资源管理实体。可以从以下几个方面进行区别：<br>进程是动态的，而程序是静态的。<br>进程有一定的生命周期，而程序是指令的集合，本身无”运动”的含义。<br>一个进程只能对应一个程序，一个程序可以对应一个进程。<br>进程和程序的关系就像戏剧和剧本之间的关系。</p>
<h3 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h3><p>线程和进程是另一对有意义的概念，主要区别和联系如下：<br>进程是操作系统进行资源分配的基本单位，拥有完整的进程空间。进行系统资源分配的时候，除了CPU资源之外，不会给线程分配独立的资源，线程所需要的资源需要共享。<br>线程是进程的一部分，如果没有进行显示的线程分配，可以认为进程是单线程的；如果进程中建立了线程，则可认为系统是多线程的。<br>多线程和多进程是两种不同的概念。多线程与多进程有不同的资源共享方式。<br>进程有进程控制块PCB，系统通过PCB对进程进行调度。进程有线程控制块TCB，但TCB所表示的状态比PCB要少的多。</p>
<h3 id="临界资源、临界区、信号量、P-V操作"><a href="#临界资源、临界区、信号量、P-V操作" class="headerlink" title="临界资源、临界区、信号量、P,V操作"></a>临界资源、临界区、信号量、P,V操作</h3><p><strong>资源：</strong><br>Linux上有硬件资源和软件资源之分。程序会受到资源限制的影响，可能在这几方面的资源限制受到影响：1.硬件方面的物理性限制（内存）；2.系统策略的限制（允许使用的CPU时间）；3.具体实现的限制（整数的长度、文件名中所允许的最大字符数）。<br><strong>临界资源：</strong><br>临界资源是一次仅允许一个进程使用的共享资源。每次只准许一个进程进入临界区，进入后不允许其他进程进入。不论是硬件临界资源，还是软件临界资源，多个进程必须互斥地对它进行访问。<br><strong>临界区：</strong><br>临界区指的是一个访问共用资源（例如：共用设备或是共用存储器）的程序片段，而这些共用资源又无法同时被多个线程访问的特性。当有线程进入临界区段时，其他线程或是进程必须等待（例如：bounded waiting 等待法），有一些同步的机制必须在临界区段的进入点与离开点实现，以确保这些共用资源是被互斥获得使用，例如：semaphore。只能被单一线程访问的设备，例如：打印机。<br><strong>信号量：</strong><br>信号量（Semaphore）有时被称为信号灯，是解决并发问题过程中所使用的一种设施，可以用来保证两个或多个关键代码段不被并发调用。一个进程在进入一个关键代码段之前，进程（或线程）必须获取一个信号量；一旦关键代码段完成了，那么该进程（或线程）必须释放信号量。其它想进入该关键代码段的进程（或线程）必须等待直到第一个进程（或线程）释放信号量。</p>
<p>从并发机制的角度看，信号量是一种并发机制，它用于进程间传递信号的一个整数值。在信号量上只有3中操作可以进行：初始化、递减和增加，这三种都是原子操作。递减操作可以用于阻塞一个进程，增加操作可以用于解除阻塞一个进程。也成为计数信号量或一般信号量。（其它的并行机制还有很多，如二元信号量、互斥量、自旋锁、事件标志等）<br><strong>简单的理解：</strong><br>信号量：特殊变量，加1（v操作，释放资源），减1（p操作，获取资源），都是一个原子操作，值为0，减1阻塞。信号量用来同步进程。同步：只有一个程序在执行。<br>五、原子操作：它在执行过程中不能被打断。<br><strong>P，V操作：</strong><br>实际上p操作就是-1（获取资源），v操作就是+1（释放资源）。</p>
<p>我的理解也就是信号量用来解决互斥问题的一种方法。设信号量为s,设有n个进程，所有的进程都需要访问共享资源。每个进程中进入临界区前执行semWait(s),如果s的值为负，则进程被阻塞，s的绝对值就是被阻塞进程的数量；如果值为1，则s被减为0，进程立即进入临界区；由于s不再为正，因而其他任何程序都不能进入临界区。信号量一般初始化为1，这样第一个执行semWait的进程可以立即进入临界区，并把s的值置为0。接着任何试图进入临界区的其他（一个）进程，都将发现第一个进程忙，因此被阻塞，把s的值置为-1。可以有任意数目的进程试图进入，每个不成功的尝试都会使s的值减1，当最初进入临界区的进程离开时，s的值增1，一个被阻塞的进程（如果有的话）被移出阻塞队列，置为就绪状态（这里的s的值增1和一个阻塞进程被移出置为就绪状态是一步完成的）。这样，当操作系统下一次调度时，它可以进入临界区，并把信号量的值置为0。</p>
<p>PV操作与信号量的处理相关，P表示通过的意思，V表示释放的意思。p操作和v操作是不可中断的程序段，称为原语。如果将信号量看作共享变量，则pv操作为其临界区，多个进程不能同时执行，一般用硬件方法保证。一个信号量只能置一次初值，以后只能对之进行p操作或v操作。<br><strong>使用PV操作实现进程互斥时应该注意的是：</strong><br>0x1 每个程序中用户实现互斥的P、V操作必须成对出现，先做P操作，进临界区，后做V操作，出临界区。若有多个分支，要认真检查其成对性。<br>0x2 P、V操作应分别紧靠临界区的头尾部，临界区的代码应尽可能短，不能有死循环。<br>0x3  互斥信号量的初值一般为1。<br><strong>一些其它的知识</strong><br>0x1 二值信号量   0   1<br>0x2 计数信号量   可能会&gt;1<br>0x3 semget 创建信号量<br>0x4 semop  修改信号量的值   实现p v操作<br>0x5 semctl   初始化信号量  删除<br>0x6 信号量的使用<br>1）创建信号量，初始化值为1<br>2）提供P V操作<br>3）使用临界资源之前执行P操作，用完执行V操作<br>4）销毁信号量<br>0x7 ipcs命令<br>ipcs –q  查看消息队列      ipcs  -s<br>ipcrm  -s  +信号量id：手动清楚信号量<br>ipcs  -m  显示共享内存</p>
]]></content>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机发展历史</title>
    <url>/2019/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6/</url>
    <content><![CDATA[<h3 id="计算机硬件发展四个经典阶段"><a href="#计算机硬件发展四个经典阶段" class="headerlink" title="计算机硬件发展四个经典阶段"></a>计算机硬件发展四个经典阶段</h3><p><strong>电子管时代【1946-1955】ENCIA</strong><br>硬件：电子管、接线面板<br>程序：二进制程序、打孔：纸带卡片<br><strong>晶体管时代【1955-1965】</strong><br>1955年IBM推出第一台晶体管计算机：典型机型7094<br><strong>集成电路时代【1965-1980】</strong><br><strong>大规模集成电路时代【1980-至今】</strong><br>1962年由ARPA支持:<br>MIT、BELL和G.E参与开发”公用计算服务系统”</p>
<h3 id="操作系统发展的四个经典阶段"><a href="#操作系统发展的四个经典阶段" class="headerlink" title="操作系统发展的四个经典阶段"></a>操作系统发展的四个经典阶段</h3><p><strong>手工操作体统（无操作系统） 50年代早期</strong><br>手工处理 繁琐耗时<br>缺点：效率低、用户独占、缺少交互<br><strong>单道批处理系统 50年代</strong><br>管理员事先讲多个作业输入到磁盘形成队列<br>操作系统依次自动处理队列的每个作业<br>程序装入和撤出自动完成效率高<br>特点：批量 自动 单道(依次处理)<br><strong>多道批处理系统 60年代初</strong><br>定义：在内存中存放多道程序，当某个程序因某种原因不能继续执行而放弃cpu时，操作系统便调度另一 程序投入 运行。<br>提高系统CPU利用率<br>提供系统吞吐量<br><strong>分时系统 60年代中</strong><br>事务性任务的涌现<br>要求支持多任务/多用户<br>多终端计算机：高性能主机+多个终端/主机采用分时技术<br>UNIX第一个实用化的分时操作系统</p>
<h3 id="操作系统的进一步发展"><a href="#操作系统的进一步发展" class="headerlink" title="操作系统的进一步发展"></a>操作系统的进一步发展</h3><p><strong>微机操作系统</strong><br>1973年：CP/M操作系统(Control Program/Microprocessor)<br>良好的层次结构：BIOS把操作系统和硬件分隔<br>1976年：苹果MAC OS和Macintosh<br>Mac OS是运行Macintosh系列电脑上的操作系统<br>Mac OS是首个配有GUI和鼠标的操作系统<br>80年代：微软MS DOS<br>磁盘操作系统/单用户单任务/MS DOS预装在IBM PC</p>
<p>微软Windows操作系统<br>1985年11月，windows 1.0正式上市<br>1992年04月，发表Windows 3.1<br>1993年05月，发表Windows NT<br>Windows 95、CE、98、2K、XP、Win7、Win 10……</p>
<p>Linux操作系统<br>Linus Torvalds[芬兰.赫尔辛基大学],1969.12<br>1994年03月，Linux 1.0正式发布<br><strong>多处理机操作系统</strong><br><strong>网络操作系统</strong><br>普通操作系统+网络通信+网络服务|<br>UNIX/LINUX/WINDOWS<br>功能：透明存取/实时控制<br><strong>实时操作系统</strong><br>实时事务:军事、工业控制、智能仪器<br>应实时系统/软实时系统<br><strong>嵌入式操作系统</strong><br>常见嵌入式操作系统：Andriod、LInux、ucOS、ucLInux</p>
]]></content>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统笔记</title>
    <url>/2019/04/27/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h3 id="计算机启动过程"><a href="#计算机启动过程" class="headerlink" title="计算机启动过程"></a>计算机启动过程</h3><p>启动bios加载bootloader,<br>bootloader读取磁盘信息加载操作系统到内存<br><a href="https://www.jianshu.com/p/f8040cc6e0de" target="_blank" rel="noopener">https://www.jianshu.com/p/f8040cc6e0de</a></p>
<h3 id="计算机体系结构"><a href="#计算机体系结构" class="headerlink" title="计算机体系结构"></a>计算机体系结构</h3><p>CPU：运算器 控制器 寄存器 缓存(Cache) 存储管理单元(MMU)<br>内存：<br>设备(I/O): 磁盘设备</p>
<p>CPU内存处理过程：L1缓存&gt;L2缓存&gt;主存(交换/分页)&gt;磁盘(虚拟内存)</p>
<h3 id="操作系统发展的四个经典阶段"><a href="#操作系统发展的四个经典阶段" class="headerlink" title="操作系统发展的四个经典阶段"></a>操作系统发展的四个经典阶段</h3><p><strong>手工操作体统（无操作系统） 50年代早期</strong><br>手工处理 繁琐耗时<br>缺点：效率低、用户独占、缺少交互<br><strong>单道批处理系统 50年代</strong><br>管理员事先讲多个作业输入到磁盘形成队列<br>操作系统依次自动处理队列的每个作业<br>程序装入和撤出自动完成效率高<br>特点：批量 自动 单道(依次处理)<br><strong>多道批处理系统 60年代初</strong><br>定义：在内存中存放多道程序，当某个程序因某种原因不能继续执行而放弃cpu时，操作系统便调度另一 程序投入 运行。<br>提高系统CPU利用率<br>提供系统吞吐量<br><strong>分时系统 60年代中</strong><br>事务性任务的涌现<br>要求支持多任务/多用户<br>多终端计算机：高性能主机+多个终端/主机采用分时技术<br>特点：多路调制性 独占性 交互性</p>
<h3 id="操作系统基本特征"><a href="#操作系统基本特征" class="headerlink" title="操作系统基本特征"></a>操作系统基本特征</h3><p>并发：并行与并发、引入进程<br>共享：互斥共享方式、同时访问方式<br>虚拟：<br>异步：在多道程序环境下，系统允许多个进程并发执行</p>
<p>0x1 并发和共享是多任务OS的最基本特征<br>0x2 虚拟性以并发性和共享性为前提<br>0x3 异步性是并发性和共享性的必然结果</p>
<h3 id="操作系统功能"><a href="#操作系统功能" class="headerlink" title="操作系统功能"></a>操作系统功能</h3><p><strong>进程管理(CPU管理)</strong><br>进程控制：创建、暂停、唤醒、撤销<br>进程调度：调度策略、优先级<br>进程通信：进程间通信<br><strong>内存管理</strong><br>内存分配 内存共享 内存保护 虚拟内存<br><strong>设备管理</strong><br>设备的分配和调度 设备无关性 设备传输控制 设备驱动<br><strong>文件管理</strong><br>存储空间管理 文件的操作 目录的操作 文件和目录的存储权限管理</p>
<h3 id="OS结构设计"><a href="#OS结构设计" class="headerlink" title="OS结构设计"></a>OS结构设计</h3><p>0x1 无结构操作系统<br>0x2 模块化操作系统<br>0x3 分层式操作系统</p>
]]></content>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>生活已经很疲惫了 就不要去招惹疲惫的感情了</title>
    <url>/2019/04/11/%E7%94%9F%E6%B4%BB%E5%B7%B2%E7%BB%8F%E5%BE%88%E7%96%B2%E6%83%AB%E4%BA%86-%E5%B0%B1%E4%B8%8D%E8%A6%81%E5%8E%BB%E6%8B%9B%E6%83%B9%E7%96%B2%E6%83%AB%E7%9A%84%E6%84%9F%E6%83%85%E4%BA%86/</url>
    <content><![CDATA[<p>已经快二十周岁 想到自己已经是成年人了 迫切需要独立 有了自己奋斗的目标。<br>不可以每天都想象着安乐的生活  在虚无缥缈的日子里渡过。<br>要学会自己照顾好自己 不要太注重感情 因为感情失去的那天 她会让你对生活充满失望 所以感情会使你更丧。<br>生活是挺累的 但有些甜甜恋爱会闯入你的生活 会让你的生活瞬间多彩。<br>但她也会让你疲惫不堪 爱情真的让人捉摸不通 让人快乐 失去后却再也找不到快乐了。<br>有时候学会放弃也是一种快乐。坚守不住的人啊 就让她走吧。没有遇见她只是时间未到。<br>有时候 人和人的出场顺序真的很重要，陪你一起喝醉的人，是没法送你回家的。<br>喜欢一个人不要觉得她对你好就要喜欢她 要找到她的一种习惯或者品格去喜欢 这样你才可以不断去加深自己对她的感情你们也才会走的长远。<br>长大了之后 渐渐地你会发现 不是所有人都适合让你去分享成功的喜悦 有的埋怨你炫耀 有的妒忌 有的不屑 所以我们都慢慢变得谦虚起来 到最后 那些能让你毫无保留地分享骄傲心情的人 那些在你得意忘形时也不会反感而带着微笑的人 才是你最重要的人。<br>​所以我们要等着更好的爱情来啊 地球是圆的 兜兜转转 你还是会找到属于你的那份甜甜的爱情</p>
<p>好的歌只会在无意间听到<br>可人们会贪心将其循环<br>直到有一天厌烦了 便丢弃在一边 但偶尔听到也会觉得好听<br>仔细想想遇到的人 喜欢的人不也是如此<br>都渴望遇到更好的而我遇见了她<br>每天想她一万一千八百遍去哪都要粘着她<br>爱很简单 只想和她眉来眼去 互相调戏讲点低俗内容 嘻嘻<br>“世界有很多恶意 但是请相信天道有轮回 我们要保持善良可爱和有趣” ​ ​​​</p>
<p>你喜欢的人一定会慢慢慢慢慢慢慢慢喜欢上你的 要相信</p>
]]></content>
      <tags>
        <tag>感情</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo 常用命令</title>
    <url>/2019/04/07/Hexo-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h3 id="Hexo常用命令"><a href="#Hexo常用命令" class="headerlink" title="Hexo常用命令"></a>Hexo常用命令</h3><p>  npm install hexo -g #安装<br>  npm update hexo -g #更新<br>  hexo init #初始化</p>
<p>  hexo n “name” #新建文章<br>  hexo g #生成静态网页<br>  hexo p #发表草稿。<br>  hexo s #启动服务<br>  hexo d #部署网站 参数：-g 部署之前先生成静态文件。</p>
<p>  npm install hexo-server –save #安装服务<br>  hexo s #启动服务<br>  hexo server -p 5000 #更改端口<br>  hexo s -s #静态模式<br>  hexo s -i 192.168.1.1 #自定义ip<br>  hexo clean #清除缓存</p>
<p>  hexo d -g #部署<br>  hexo g -d</p>
<p>CD /H/hexo/blog/myblog</p>
]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>关于我</title>
    <url>/2019/04/07/%E5%85%B3%E4%BA%8E%E6%88%91/</url>
    <content><![CDATA[<h3 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h3><p>三本院校网络工程专业大二学生<br>平时喜欢看一些技术blog<br>乏创新思维的工科男<br>对待感情比较感性想成为有趣的人<br>努力在这个喧嚣的时代保持独立思考</p>
<h3 id="学习方向"><a href="#学习方向" class="headerlink" title="学习方向"></a>学习方向</h3><p>网络工程专业，目前没有很明确的目标，以后想从事网络安全方面，目前正在学习Python、算法以及网络方面基础内容，争取多参加一些比赛，本科毕业后有考研想法。</p>
<h3 id="关于本博客"><a href="#关于本博客" class="headerlink" title="关于本博客"></a>关于本博客</h3><p>这个博客框架诞生于2019年4月初，在HTML5课堂上突然看到了一位博主的博客，大概看了一下是基于Hexo+Github托管，然后就开始琢磨各种模板，最终选择了Next。</p>
<p>在经历了CSDN和一些博主博客后，开始安装Node.js和Git Bush工具，根据一篇Blog完成了Hexo网页框架，在不断的完善下有了今天，虽然还不是很完善，也终于有了一种寄人篱下的感觉。</p>
<p>日后也会不断地完善现在这个博客，不断的优化，也会不断地写Blog把学习经历记录下来。</p>
<h3 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h3><p>我逐渐发现，自己还很幼稚，无论从思想上讲还是技术上。所以很长一段时间我都会留下一些笔记性质的文章，它对读者不是很友好，当然比纯笔记更开放。发文章的频率会很高，现在这个博客，更像是我目前学习状况的详细体现。</p>
<p>网络上的每个人都在浪潮中浮沉，每个人都希望能在登上一座岛后发现崖下秘籍，然后站在聚光灯下，得到形而上的成功。我必须提前告诉你，这座岛上没有这些东西，不过它也不是海市蜃楼，没那么玄乎其神，没准能为你的生活增添一些乐趣和惊喜。</p>
<p>希望你和我都能，把假大空的人生，变成看得见摸得着的欲望。</p>
<p>旅途愉快。</p>
]]></content>
  </entry>
</search>
